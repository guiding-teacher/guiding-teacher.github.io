<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø®ØªØ¨Ø± Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø³Ø­Ø±ÙŠ - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­ØªØ±ÙØ©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bottle-width: 80px;
            --bottle-height: 220px;
            --liquid-unit-height: 44px;
        }

        body {
            font-family: 'Tajawal', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            min-height: 100vh;
        }

        .gradient-bg {
            background: linear-gradient(135deg, #1f2937 0%, #374151 50%, #111827 100%);
        }
        
        .glass-effect {
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.125);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.36);
            transition: all 0.3s ease;
        }
        
        .neon-glow {
            transition: all 0.3s ease;
        }
        .neon-glow:hover {
            filter: drop-shadow(0 0 12px currentColor);
            transform: translateY(-2px);
        }
        .neon-glow-permanent {
            filter: drop-shadow(0 0 8px currentColor);
        }
        
        .bottle {
            width: var(--bottle-width);
            height: var(--bottle-height);
            position: relative;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: bottom center;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }
        
        .bottle-body {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: calc(100% - 25px);
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.2) 100%);
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-top: none;
            border-radius: 0 0 35px 35px;
            overflow: hidden;
        }
        
        .bottle-neck {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 45%;
            height: 25px;
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.2) 100%);
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-bottom: none;
            border-radius: 15px 15px 0 0;
        }
        
        .bottle.selected {
            transform: translateY(-15px) scale(1.08);
            filter: drop-shadow(0 0 20px #3b82f6);
        }

        .liquid-stack {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column-reverse;
            border-radius: 0 0 32px 32px;
            overflow: hidden;
        }
        
        .liquid-unit {
            height: var(--liquid-unit-height);
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
        }
        
        .liquid-unit::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }
        
        .pour-animation {
            animation: pour 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        @keyframes pour {
            0% { transform: translateY(0) rotate(0deg); }
            30% { transform: translateY(-30px) rotate(45deg); }
            60% { transform: translateY(-30px) rotate(45deg); }
            100% { transform: translateY(0) rotate(0deg); }
        }
        
        .liquid-transfer {
            position: absolute;
            width: 60px;
            height: 20px;
            background: currentColor;
            border-radius: 50%;
            opacity: 0;
            z-index: 10;
            filter: drop-shadow(0 0 8px currentColor);
            animation: transfer 1s ease-in-out forwards;
        }
        
        @keyframes transfer {
            0% { transform: scale(0.5); opacity: 0; }
            20% { transform: scale(1); opacity: 0.8; }
            80% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(0.5); opacity: 0; }
        }

        .success-sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            filter: blur(1px);
            animation: sparkle-burst 1.2s ease-out forwards;
        }
        
        @keyframes sparkle-burst {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            50% { transform: scale(1) rotate(180deg); opacity: 0.7; }
            100% { transform: scale(2) rotate(360deg); opacity: 0; }
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
        }

        .level-badge {
            background: linear-gradient(135deg, #8b5cf6 0%, #3b82f6 100%);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }
        
        .progress-bar {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #3b82f6 100%);
            transition: width 0.3s ease;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            :root {
                --bottle-width: 70px;
                --bottle-height: 190px;
                --liquid-unit-height: 38px;
            }
        }
        @media (max-width: 480px) {
            :root {
                --bottle-width: 60px;
                --bottle-height: 170px;
                --liquid-unit-height: 34px;
            }
        }
    </style>
</head>
<body class="min-h-screen text-white overflow-x-hidden">
    <div id="root" class="relative z-10 p-4 sm:p-6">
        <!-- Animated Background -->
        <div class="fixed inset-0 -z-10 overflow-hidden">
            <div class="absolute -inset-10 opacity-20">
                <div class="absolute top-1/4 left-1/4 w-64 h-64 bg-purple-500 rounded-full mix-blend-multiply filter blur-3xl opacity-30 animate-pulse"></div>
                <div class="absolute top-1/3 right-1/4 w-64 h-64 bg-blue-500 rounded-full mix-blend-multiply filter blur-3xl opacity-30 animate-pulse" style="animation-delay: 1s;"></div>
                <div class="absolute bottom-1/4 left-1/2 w-64 h-64 bg-cyan-500 rounded-full mix-blend-multiply filter blur-3xl opacity-30 animate-pulse" style="animation-delay: 2s;"></div>
            </div>
        </div>
<h1 class="text-2xl sm:text-3xl font-bold neon-glow-permanent text-blue-400">Ù…Ø®ØªØ¨Ø± Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø³Ø­Ø±ÙŠ</h1>
        <!-- Header -->
        <header class="flex justify-between items-center mb-8">
              
            
                  <button type="button" class="glass-effect rounded-2xl px-4 py-2 flex items-center gap-2" style="background-color: #5becbd;  " onclick="window.location.href='/drsne/reding/index.html'">
     Ø§Ù„Ø¹ÙˆØ¯Ø©   
</button>                   
              
           
            <div class="flex items-center gap-4">
                <div class="glass-effect rounded-2xl px-4 py-2 flex items-center gap-2">
                    <span>ğŸ’</span>
                    <span id="gems">0</span>
                </div>
                <div class="glass-effect rounded-2xl px-4 py-2 flex items-center gap-2">
                    <span>â­</span>
                    <span id="stars">0</span>
                </div>
                <button id="soundToggle" class="glass-effect rounded-2xl p-3 hover:bg-blue-600 transition-all neon-glow">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                        <path id="soundIconPath" fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293 1.293a1 1 0 01-1.414-1.414L13.586 10l-1.293-1.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            
                  
        </header>

        <!-- Level Selection Screen -->
        <section id="levelSelection" class="hidden">
            <!-- Levels will be dynamically generated here -->
        </section>

        <!-- Game Screen -->
        <section id="gameScreen" class="hidden">
            <div class="flex flex-col items-center mb-8">
                <div class="glass-effect rounded-2xl p-6 mb-4 w-full max-w-2xl">
                    <div class="flex justify-between items-center mb-4">
                        <h2 id="currentLevelDisplay" class="text-xl font-bold"></h2>
                        <div class="flex items-center gap-4">
                            <div class="flex items-center gap-2">
                                <span>â±ï¸</span>
                                <span id="timer" class="text-xl font-bold">60</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span>ğŸ¯</span>
                                <span id="moves" class="text-xl font-bold">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <h3 id="targetWord" class="text-2xl font-bold"></h3>
                        <div class="flex gap-2">
                            <button id="speakBtn" class="glass-effect rounded-2xl p-2 hover:bg-blue-600 transition-all neon-glow">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="mt-4">
                        <div class="flex justify-between text-sm mb-1">
                            <span>Ø§Ù„ØªÙ‚Ø¯Ù…</span>
                            <span id="progressText">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="flex gap-4">
                    <button id="resetBtn" class="glass-effect rounded-2xl px-4 py-2 hover:bg-red-600 transition-all neon-glow">
                        Ø¥Ø¹Ø§Ø¯Ø©
                    </button>
                    <button id="hintBtn" class="glass-effect rounded-2xl px-4 py-2 hover:bg-yellow-600 transition-all neon-glow">
                        ØªÙ„Ù…ÙŠØ­ (5 ğŸ’)
                    </button>
                </div>
            </div>

            <div id="bottlesArea" class="flex flex-wrap justify-center gap-6 mb-8">
                <!-- Bottles will be dynamically generated here -->
            </div>
        </section>

        <!-- Modal Container -->
        <div id="modalContainer" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 opacity-0 pointer-events-none transition-opacity duration-300">
            <!-- Level Start Modal -->
            <div id="levelStartModal" class="glass-effect rounded-2xl p-8 max-w-md w-full mx-4 transform scale-95 transition-transform duration-300 hidden">
                <h2 class="text-3xl font-bold mb-4 text-center">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ø³ØªÙˆÙ‰</h2>
                <div class="mb-6">
                    <p class="text-xl mb-2"><span class="font-bold">Ø§Ù„ÙƒÙ„Ù…Ø©:</span> <span id="startWord"></span></p>
                    <p class="text-lg mb-2"><span class="font-bold">Ø§Ù„Ù…Ø¹Ù†Ù‰:</span> <span id="startMeaning"></span></p>
                    <p class="text-lg"><span class="font-bold" id="startSentence"></span></p>
                </div>
                <div class="flex justify-center gap-4">
                    <button id="startLevelBtn" class="bg-blue-600 hover:bg-blue-700 rounded-2xl px-6 py-3 transition-all neon-glow font-bold">
                        Ø§Ø¨Ø¯Ø£
                    </button>
                </div>
            </div>

            <!-- Success Modal -->
            <div id="successModal" class="glass-effect rounded-2xl p-8 max-w-md w-full mx-4 transform scale-95 transition-transform duration-300 hidden">
                <h2 class="text-3xl font-bold mb-4 text-center text-green-400">Ù…Ø¨Ø±ÙˆÙƒ!</h2>
                <div class="mb-6 text-center">
                    <p class="text-xl mb-2">Ù„Ù‚Ø¯ Ø£ÙƒÙ…Ù„Øª Ø§Ù„ÙƒÙ„Ù…Ø©:</p>
                    <p id="completedWord" class="text-3xl font-bold mb-4"></p>
                    <div class="flex justify-center gap-6 mb-4">
                        <div class="flex items-center gap-2">
                            <span>ğŸ’</span>
                            <span id="gemsEarned">+10</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <span>â­</span>
                            <span id="starsEarned">+3</span>
                        </div>
                    </div>
                    <div class="text-sm text-gray-300">
                        <p>Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø±ÙƒØ§Øª: <span id="movesCount">0</span></p>
                        <p>Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <span id="timeLeft">0</span> Ø«Ø§Ù†ÙŠØ©</p>
                    </div>
                </div>
                <div class="flex justify-center gap-4">
                    <button id="nextLevelBtn" class="bg-green-600 hover:bg-green-700 rounded-2xl px-6 py-3 transition-all neon-glow font-bold">
                        Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ
                    </button>
                </div>
            </div>

            <!-- Game Over Modal -->
            <div id="gameOverModal" class="glass-effect rounded-2xl p-8 max-w-md w-full mx-4 transform scale-95 transition-transform duration-300 hidden">
                <h2 class="text-3xl font-bold mb-4 text-center text-red-400">Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª!</h2>
                <div class="mb-6 text-center">
                    <p class="text-xl mb-4">Ù„Ù… ØªØªÙ…ÙƒÙ† Ù…Ù† Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ÙƒÙ„Ù…Ø© ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯.</p>
                </div>
                <div class="flex justify-center gap-4">
                    <button id="retryBtn" class="bg-red-600 hover:bg-red-700 rounded-2xl px-6 py-3 transition-all neon-glow font-bold">
                        Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ProfessionalColorSortGame {
            constructor() {
                this.DOM = {
                    root: document.getElementById('root'),
                    levelSelection: document.getElementById('levelSelection'),
                    gameScreen: document.getElementById('gameScreen'),
                    bottlesArea: document.getElementById('bottlesArea'),
                    gems: document.getElementById('gems'),
                    stars: document.getElementById('stars'),
                    timer: document.getElementById('timer'),
                    targetWord: document.getElementById('targetWord'),
                    currentLevelDisplay: document.getElementById('currentLevelDisplay'),
                    backBtn: document.getElementById('backBtn'),
                    soundToggle: document.getElementById('soundToggle'),
                    soundIconPath: document.getElementById('soundIconPath'),
                    speakBtn: document.getElementById('speakBtn'),
                    resetBtn: document.getElementById('resetBtn'),
                    hintBtn: document.getElementById('hintBtn'),
                    modalContainer: document.getElementById('modalContainer'),
                    levelStartModal: document.getElementById('levelStartModal'),
                    successModal: document.getElementById('successModal'),
                    gameOverModal: document.getElementById('gameOverModal'),
                    startLevelBtn: document.getElementById('startLevelBtn'),
                    nextLevelBtn: document.getElementById('nextLevelBtn'),
                    retryBtn: document.getElementById('retryBtn'),
                    moves: document.getElementById('moves'),
                    progressFill: document.getElementById('progressFill'),
                    progressText: document.getElementById('progressText'),
                    movesCount: document.getElementById('movesCount'),
                    timeLeft: document.getElementById('timeLeft')
                };

                this.config = {
                    bottleCapacity: 4,
                    baseLevelTime: 90,
                    hintCost: 5
                };

                this.gameState = {
                    gems: 100,
                    stars: 20,
                    unlockedWorlds: ['Ø­ÙŠÙˆØ§Ù†Ø§Øª', 'ÙÙˆØ§ÙƒÙ‡'],
                    completedLevels: [],
                    currentLevel: null,
                    bottleContents: [],
                    selectedBottleIndex: null,
                    isPouring: false,
                    timeLeft: 0,
                    timer: null,
                    moves: 0,
                    maxMoves: 0
                };

                this.colorMap = {
                    'Ø£': '#FF6B6B',
                    'Ø¨': '#4ECDC4',
                    'Øª': '#45B7D1',
                    'Ø«': '#96CEB4',
                    'Ø¬': '#FFEAA7',
                    'Ø­': '#DDA0DD',
                    'Ø®': '#98D8C8',
                    'Ø¯': '#F7DC6F',
                    'Ø°': '#BB8FCE',
                    'Ø±': '#85C1E9',
                    'Ø²': '#F8C471',
                    'Ø³': '#82E0AA',
                    'Ø´': '#F1948A',
                    'Øµ': '#AED6F1',
                    'Ø¶': '#F9E79F',
                    'Ø·': '#D2B4DE',
                    'Ø¸': '#A9DFBF',
                    'Ø¹': '#F5B7B1',
                    'Øº': '#AED6F1',
                    'Ù': '#ABEBC6',
                    'Ù‚': '#FAD7A0',
                    'Ùƒ': '#D7BDE2',
                    'Ù„': '#A3E4D7',
                    'Ù…': '#F5CBA7',
                    'Ù†': '#D6EAF8',
                    'Ù‡': '#D5DBDB',
                    'Ùˆ': '#FADBD8',
                    'ÙŠ': '#D1F2EB',
                    'Ø©': '#FADBD8',
                    'Ù‰': '#D1F2EB',
                    'Ø¦': '#F5B7B1',
                    'Ø¡': '#85C1E9',
                    'Ø¤': '#F8C471'
                };

                this.levels = {
                    'Ø­ÙŠÙˆØ§Ù†Ø§Øª': [
                        { word: 'Ù‚Ø·', meaning: 'Ø­ÙŠÙˆØ§Ù† Ø£Ù„ÙŠÙ', sentence: 'Ø§Ù„Ù‚Ø·Ø© ØªÙ„Ø¹Ø¨ ÙÙŠ Ø§Ù„Ø­Ø¯ÙŠÙ‚Ø©', difficulty: 1 },
                        { word: 'Ø£Ø³Ø¯', meaning: 'Ù…Ù„Ùƒ Ø§Ù„ØºØ§Ø¨Ø©', sentence: 'Ø§Ù„Ø£Ø³Ø¯ ÙŠØµØ·Ø§Ø¯ ÙØ±ÙŠØ³ØªÙ‡', difficulty: 1 },
                        { word: 'Ù†Ù…Ø±', meaning: 'Ø­ÙŠÙˆØ§Ù† Ù…ÙØªØ±Ø³ Ù…Ø®Ø·Ø·', sentence: 'Ø§Ù„Ù†Ù…Ø± ÙŠØ¬Ø±ÙŠ Ø¨Ø³Ø±Ø¹Ø©', difficulty: 2 },
                        { word: 'ÙÙŠÙ„', meaning: 'Ø£ÙƒØ¨Ø± Ø­ÙŠÙˆØ§Ù† Ø¨Ø±ÙŠ', sentence: 'Ø§Ù„ÙÙŠÙ„ ÙŠØ´Ø±Ø¨ Ø§Ù„Ù…Ø§Ø¡ Ø¨Ø®Ø±Ø·ÙˆÙ…Ù‡', difficulty: 2 },
                        { word: 'ØºØ²Ø§Ù„', meaning: 'Ø­ÙŠÙˆØ§Ù† Ø±Ø´ÙŠÙ‚', sentence: 'Ø§Ù„ØºØ²Ø§Ù„ ÙŠÙ‚ÙØ² ÙÙŠ Ø§Ù„Ø¨Ø±ÙŠØ©', difficulty: 3 },
                        { word: 'Ø²Ø±Ø§ÙØ©', meaning: 'Ø­ÙŠÙˆØ§Ù† Ø·ÙˆÙŠÙ„ Ø§Ù„Ø±Ù‚Ø¨Ø©', sentence: 'Ø§Ù„Ø²Ø±Ø§ÙØ© ØªØ£ÙƒÙ„ Ù…Ù† Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ø§Ù„Ø¹Ø§Ù„ÙŠØ©', difficulty: 3 },
                        { word: 'ØªÙ…Ø³Ø§Ø­', meaning: 'Ø²ÙˆØ§Ø­Ù Ù…Ø§Ø¦ÙŠØ©', sentence: 'Ø§Ù„ØªÙ…Ø³Ø§Ø­ ÙŠØ³Ø¨Ù‚ ÙÙŠ Ø§Ù„Ù†Ù‡Ø±', difficulty: 4 },
                        { word: 'Ø¯Ù„ÙÙŠÙ†', meaning: 'Ø­ÙŠÙˆØ§Ù† Ø¨Ø­Ø±ÙŠ Ø°ÙƒÙŠ', sentence: 'Ø§Ù„Ø¯Ù„ÙÙŠÙ† ÙŠÙ‚ÙØ² ÙÙˆÙ‚ Ø§Ù„Ù…Ø§Ø¡', difficulty: 4 }
                    ],
                    'ÙÙˆØ§ÙƒÙ‡': [
                        { word: 'ØªÙØ§Ø­', meaning: 'ÙØ§ÙƒÙ‡Ø© Ø­Ù…Ø±Ø§Ø¡ Ø£Ùˆ Ø®Ø¶Ø±Ø§Ø¡', sentence: 'Ø§Ù„ØªÙØ§Ø­Ø© ÙØ§ÙƒÙ‡Ø© Ù„Ø°ÙŠØ°Ø©', difficulty: 1 },
                        { word: 'Ù…ÙˆØ²', meaning: 'ÙØ§ÙƒÙ‡Ø© ØµÙØ±Ø§Ø¡ Ø·ÙˆÙŠÙ„Ø©', sentence: 'Ø§Ù„Ù…ÙˆØ² ØºÙ†ÙŠ Ø¨Ø§Ù„Ø¨ÙˆØªØ§Ø³ÙŠÙˆÙ…', difficulty: 1 },
                        { word: 'Ø¨Ø±ØªÙ‚Ø§Ù„', meaning: 'ÙØ§ÙƒÙ‡Ø© Ø­Ù…Ø¶ÙŠØ© Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠØ©', sentence: 'Ø§Ù„Ø¨Ø±ØªÙ‚Ø§Ù„ Ù…ØµØ¯Ø± Ù„ÙÙŠØªØ§Ù…ÙŠÙ† Ø³ÙŠ', difficulty: 2 },
                        { word: 'ÙØ±Ø§ÙˆÙ„Ø©', meaning: 'ÙØ§ÙƒÙ‡Ø© Ø­Ù…Ø±Ø§Ø¡ ØµØºÙŠØ±Ø©', sentence: 'Ø§Ù„ÙØ±Ø§ÙˆÙ„Ø© Ø­Ù„ÙˆØ© Ø§Ù„Ù…Ø°Ø§Ù‚', difficulty: 2 },
                        { word: 'Ø¹Ù†Ø¨', meaning: 'ÙØ§ÙƒÙ‡Ø© ØªÙ†Ù…Ùˆ ÙÙŠ Ø¹Ù†Ø§Ù‚ÙŠØ¯', sentence: 'Ø§Ù„Ø¹Ù†Ø¨ ÙŠØ£ØªÙŠ Ø¨Ø£Ù„ÙˆØ§Ù† Ù…Ø®ØªÙ„ÙØ©', difficulty: 3 },
                        { word: 'Ø£Ù†Ø§Ù†Ø§Ø³', meaning: 'ÙØ§ÙƒÙ‡Ø© Ø§Ø³ØªÙˆØ§Ø¦ÙŠØ©', sentence: 'Ø§Ù„Ø£Ù†Ø§Ù†Ø§Ø³ Ø­Ù„Ùˆ ÙˆÙ„Ø°ÙŠØ°', difficulty: 3 },
                        { word: 'Ø±Ù…Ø§Ù†', meaning: 'ÙØ§ÙƒÙ‡Ø© Ø­Ù…Ø±Ø§Ø¡ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨Ø°ÙˆØ±', sentence: 'Ø§Ù„Ø±Ù…Ø§Ù† ÙØ§ÙƒÙ‡Ø© Ù…ÙÙŠØ¯Ø© Ù„Ù„ØµØ­Ø©', difficulty: 4 },
                        { word: 'Ù…Ø§Ù†Ø¬Ùˆ', meaning: 'ÙØ§ÙƒÙ‡Ø© Ø§Ø³ØªÙˆØ§Ø¦ÙŠØ© Ø­Ù„ÙˆØ©', sentence: 'Ø§Ù„Ù…Ø§Ù†Ø¬Ùˆ ÙØ§ÙƒÙ‡Ø© Ø§Ù„ØµÙŠÙ Ø§Ù„Ù…ÙØ¶Ù„Ø©', difficulty: 4 }
                    ],
                    'Ø£Ù„ÙˆØ§Ù†': [
                        { word: 'Ø£Ø­Ù…Ø±', meaning: 'Ù„ÙˆÙ† Ø§Ù„Ù†Ø§Ø± ÙˆØ§Ù„Ø¯Ù…', sentence: 'Ø§Ù„ÙˆØ±Ø¯ Ø§Ù„Ø£Ø­Ù…Ø± Ø¬Ù…ÙŠÙ„', difficulty: 1 },
                        { word: 'Ø£Ø²Ø±Ù‚', meaning: 'Ù„ÙˆÙ† Ø§Ù„Ø³Ù…Ø§Ø¡ ÙˆØ§Ù„Ø¨Ø­Ø±', sentence: 'Ø§Ù„Ø³Ù…Ø§Ø¡ Ø²Ø±Ù‚Ø§Ø¡ ØµØ§ÙÙŠØ©', difficulty: 1 },
                        { word: 'Ø£Ø®Ø¶Ø±', meaning: 'Ù„ÙˆÙ† Ø§Ù„Ø·Ø¨ÙŠØ¹Ø© ÙˆØ§Ù„Ù†Ø¨Ø§ØªØ§Øª', sentence: 'Ø§Ù„Ø¹Ø´Ø¨ Ø£Ø®Ø¶Ø± Ø§Ù„Ù„ÙˆÙ†', difficulty: 2 },
                        { word: 'Ø£ØµÙØ±', meaning: 'Ù„ÙˆÙ† Ø§Ù„Ø´Ù…Ø³ ÙˆØ§Ù„Ø°Ù‡Ø¨', sentence: 'Ø§Ù„Ù„ÙŠÙ…ÙˆÙ† Ø£ØµÙØ± Ø§Ù„Ù„ÙˆÙ†', difficulty: 2 },
                        { word: 'Ø¨Ù†ÙØ³Ø¬ÙŠ', meaning: 'Ù„ÙˆÙ† Ù…Ø²ÙŠØ¬ Ù…Ù† Ø§Ù„Ø£Ø­Ù…Ø± ÙˆØ§Ù„Ø£Ø²Ø±Ù‚', sentence: 'Ø§Ù„Ø²Ù†Ø¨Ù‚ Ø§Ù„Ø¨Ù†ÙØ³Ø¬ÙŠ Ù†Ø§Ø¯Ø±', difficulty: 3 },
                        { word: 'Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ', meaning: 'Ù„ÙˆÙ† Ù…Ø²ÙŠØ¬ Ù…Ù† Ø§Ù„Ø£Ø­Ù…Ø± ÙˆØ§Ù„Ø£ØµÙØ±', sentence: 'Ø§Ù„Ø¬Ø²Ø± Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ Ø§Ù„Ù„ÙˆÙ†', difficulty: 3 },
                        { word: 'Ø²Ù‡Ø±ÙŠ', meaning: 'Ù„ÙˆÙ† ÙØ§ØªØ­ Ù…Ù† Ø§Ù„Ø£Ø­Ù…Ø±', sentence: 'Ø§Ù„ÙˆØ±Ø¯ Ø§Ù„Ø²Ù‡Ø±ÙŠ Ø¬Ù…ÙŠÙ„', difficulty: 4 },
                        { word: 'Ø°Ù‡Ø¨ÙŠ', meaning: 'Ù„ÙˆÙ† Ø§Ù„Ù…Ø¹Ø¯Ù† Ø§Ù„Ø«Ù…ÙŠÙ†', sentence: 'Ø§Ù„Ø®Ø§ØªÙ… Ø§Ù„Ø°Ù‡Ø¨ÙŠ Ø«Ù…ÙŠÙ†', difficulty: 4 }
                    ],
                    'Ø£Ù…Ø§ÙƒÙ†': [
                        { word: 'Ù…Ø¯Ø±Ø³Ø©', meaning: 'Ù…ÙƒØ§Ù† Ù„Ù„ØªØ¹Ù„Ù…', sentence: 'Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠØ¯Ø±Ø³ÙˆÙ† ÙÙŠ Ø§Ù„Ù…Ø¯Ø±Ø³Ø©', difficulty: 1 },
                        { word: 'Ù…Ø³ØªØ´ÙÙ‰', meaning: 'Ù…ÙƒØ§Ù† Ù„Ù„Ø¹Ù„Ø§Ø¬', sentence: 'Ø§Ù„Ø·Ø¨ÙŠØ¨ ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø³ØªØ´ÙÙ‰', difficulty: 1 },
                        { word: 'Ù…Ø·Ø¹Ù…', meaning: 'Ù…ÙƒØ§Ù† Ù„ØªÙ†Ø§ÙˆÙ„ Ø§Ù„Ø·Ø¹Ø§Ù…', sentence: 'Ù†Ø­Ù† Ù†Ø£ÙƒÙ„ ÙÙŠ Ø§Ù„Ù…Ø·Ø¹Ù…', difficulty: 2 },
                        { word: 'Ø­Ø¯ÙŠÙ‚Ø©', meaning: 'Ù…ÙƒØ§Ù† Ù„Ù„ØªØ±ÙÙŠÙ‡ ÙˆØ§Ù„Ù„Ø¹Ø¨', sentence: 'Ø§Ù„Ø£Ø·ÙØ§Ù„ ÙŠÙ„Ø¹Ø¨ÙˆÙ† ÙÙŠ Ø§Ù„Ø­Ø¯ÙŠÙ‚Ø©', difficulty: 2 },
                        { word: 'Ù…ÙƒØªØ¨Ø©', meaning: 'Ù…ÙƒØ§Ù† Ù„Ù„Ù‚Ø±Ø§Ø¡Ø© ÙˆØ§Ù„Ø§Ø³ØªØ¹Ø§Ø±Ø©', sentence: 'Ø§Ù„ÙƒØªØ¨ Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ù…ÙƒØªØ¨Ø©', difficulty: 3 },
                        { word: 'Ù…ØªØ¬Ø±', meaning: 'Ù…ÙƒØ§Ù† Ù„Ø¨ÙŠØ¹ Ø§Ù„Ø¨Ø¶Ø§Ø¦Ø¹', sentence: 'Ø§Ø´ØªØ±ÙŠØª Ù‡Ø¯ÙŠØ© Ù…Ù† Ø§Ù„Ù…ØªØ¬Ø±', difficulty: 3 },
                        { word: 'Ù…Ø·Ø§Ø±', meaning: 'Ù…ÙƒØ§Ù† Ù„Ù„Ø³ÙØ± ÙˆØ§Ù„Ø·Ø§Ø¦Ø±Ø§Øª', sentence: 'Ø§Ù„Ù…Ø³Ø§ÙØ±ÙˆÙ† ÙŠØ°Ù‡Ø¨ÙˆÙ† Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø·Ø§Ø±', difficulty: 4 },
                        { word: 'ÙÙ†Ø¯Ù‚', meaning: 'Ù…ÙƒØ§Ù† Ù„Ù„Ø¥Ù‚Ø§Ù…Ø©', sentence: 'Ù†Ù‚ÙŠÙ… ÙÙŠ Ø§Ù„ÙÙ†Ø¯Ù‚ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø³ÙØ±', difficulty: 4 }
                    ],
                    'ÙˆØ¸Ø§Ø¦Ù': [
                        { word: 'Ø·Ø¨ÙŠØ¨', meaning: 'ÙŠØ¹Ø§Ù„Ø¬ Ø§Ù„Ù…Ø±Ø¶Ù‰', sentence: 'Ø§Ù„Ø·Ø¨ÙŠØ¨ ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø³ØªØ´ÙÙ‰', difficulty: 2 },
                        { word: 'Ù…Ù‡Ù†Ø¯Ø³', meaning: 'ÙŠØµÙ…Ù… Ø§Ù„Ù…Ø¨Ø§Ù†ÙŠ ÙˆØ§Ù„Ø¬Ø³ÙˆØ±', sentence: 'Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ ÙŠØµÙ…Ù… Ø§Ù„Ù…Ù†Ø§Ø²Ù„', difficulty: 2 },
                        { word: 'Ù…Ø¹Ù„Ù…', meaning: 'ÙŠØ¹Ù„Ù… Ø§Ù„Ø·Ù„Ø§Ø¨', sentence: 'Ø§Ù„Ù…Ø¹Ù„Ù… ÙŠØ´Ø±Ø­ Ø§Ù„Ø¯Ø±Ø³', difficulty: 3 },
                        { word: 'Ø·ÙŠØ§Ø±', meaning: 'ÙŠÙ‚ÙˆØ¯ Ø§Ù„Ø·Ø§Ø¦Ø±Ø©', sentence: 'Ø§Ù„Ø·ÙŠØ§Ø± ÙŠØ­Ù„Ù‚ ÙÙŠ Ø§Ù„Ø³Ù…Ø§Ø¡', difficulty: 3 },
                        { word: 'Ø´Ø±Ø·ÙŠ', meaning: 'ÙŠØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù…Ù†', sentence: 'Ø§Ù„Ø´Ø±Ø·ÙŠ ÙŠÙ†Ø¸Ù… Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø±ÙˆØ±', difficulty: 4 },
                        { word: 'Ù…Ù…Ø±Ø¶', meaning: 'ÙŠØ¹ØªÙ†ÙŠ Ø¨Ø§Ù„Ù…Ø±Ø¶Ù‰', sentence: 'Ø§Ù„Ù…Ù…Ø±Ø¶ ÙŠØ³Ø§Ø¹Ø¯ Ø§Ù„Ø·Ø¨ÙŠØ¨', difficulty: 4 }
                    ],
                    'Ø¨Ù„Ø¯Ø§Ù†': [
                        { word: 'Ù…ØµØ±', meaning: 'Ø¨Ù„Ø¯ ÙÙŠ Ø´Ù…Ø§Ù„ Ø£ÙØ±ÙŠÙ‚ÙŠØ§', sentence: 'Ù…ØµØ± Ø¨Ù„Ø¯ Ø§Ù„Ø£Ù‡Ø±Ø§Ù…Ø§Øª', difficulty: 3 },
                        { word: 'Ø³Ø¹ÙˆØ¯ÙŠØ©', meaning: 'Ø¨Ù„Ø¯ ÙÙŠ Ø´Ø¨Ù‡ Ø§Ù„Ø¬Ø²ÙŠØ±Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', sentence: 'Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ© Ø¨Ù„Ø¯ Ø§Ù„Ø­Ø±Ù…ÙŠÙ†', difficulty: 3 },
                        { word: 'Ø£Ø±Ø¯Ù†', meaning: 'Ø¨Ù„Ø¯ ÙÙŠ Ø§Ù„Ø´Ø±Ù‚ Ø§Ù„Ø£ÙˆØ³Ø·', sentence: 'Ø§Ù„Ø£Ø±Ø¯Ù† Ø¨Ù„Ø¯ Ø§Ù„Ø¢Ø«Ø§Ø±', difficulty: 4 },
                        { word: 'Ø¹Ø±Ø§Ù‚', meaning: 'Ø¨Ù„Ø¯ Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‡Ø±ÙŠÙ†', sentence: 'Ø§Ù„Ø¹Ø±Ø§Ù‚ Ø¨Ù„Ø¯ Ø§Ù„Ø­Ø¶Ø§Ø±Ø§Øª', difficulty: 4 },
                        { word: 'ÙŠÙ…Ù†', meaning: 'Ø¨Ù„Ø¯ ÙÙŠ Ø¬Ù†ÙˆØ¨ Ø§Ù„Ø¬Ø²ÙŠØ±Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', sentence: 'Ø§Ù„ÙŠÙ…Ù† Ø¨Ù„Ø¯ Ø§Ù„ØªØ§Ø±ÙŠØ®', difficulty: 4 }
                    ]
                };

                this.soundManager = this.createSoundManager();
                this.init();
            }

            init() {
                this.loadProgress();
                this.updateHeaderUI();
                this.showLevelSelection();
                this.bindEvents();
                this.soundManager.init();
            }

            createSoundManager() {
                let audioContext;
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser.");
                    return { init: ()=>{}, play: ()=>{}, toggle: ()=>{} };
                }

                const sounds = {
                    click: this.generateBubbleSound(),
                    pour: this.generatePourSound(),
                    success: this.generateSuccessSound(),
                    fail: this.generateFailSound(),
                    bgMusic: this.generateBackgroundMusic()
                };

                const audioBuffers = {};
                let soundEnabled = true;
                let bgMusicNode = null;
                let userInteracted = false;

                const loadSound = (key) => {
                    try {
                        const buffer = audioContext.createBuffer(1, sounds[key].length, audioContext.sampleRate);
                        const channelData = buffer.getChannelData(0);
                        for (let i = 0; i < sounds[key].length; i++) {
                            channelData[i] = sounds[key][i];
                        }
                        audioBuffers[key] = buffer;
                        if(key === 'bgMusic') {
                            initBgMusic();
                        }
                    } catch (e) {
                        console.error("Error loading sound:", e);
                    }
                };

                const initBgMusic = () => {
                    if (!audioBuffers.bgMusic) return;
                    if (bgMusicNode) bgMusicNode.stop();

                    bgMusicNode = audioContext.createBufferSource();
                    bgMusicNode.buffer = audioBuffers.bgMusic;
                    bgMusicNode.loop = true;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0.2;
                    bgMusicNode.connect(gainNode).connect(audioContext.destination);

                    if (soundEnabled && userInteracted) {
                        try { bgMusicNode.start(0); } catch(e) {}
                    }
                };
                
                Object.keys(sounds).forEach(loadSound);

                return {
                    init: () => {
                        if (!userInteracted) {
                            const startInteraction = () => {
                                userInteracted = true;
                                if (audioContext.state === 'suspended') {
                                    audioContext.resume();
                                }
                                initBgMusic();
                                window.removeEventListener('click', startInteraction);
                                window.removeEventListener('touchstart', startInteraction);
                            }
                            window.addEventListener('click', startInteraction);
                            window.addEventListener('touchstart', startInteraction);
                        }
                    },
                    play: (sound) => {
                        if (!soundEnabled || !audioBuffers[sound]) return;
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffers[sound];
                        source.connect(audioContext.destination);
                        source.start(0);
                    },
                    toggle: (enabled) => {
                        soundEnabled = enabled;
                        if (soundEnabled) {
                            if (audioContext.state === 'suspended') audioContext.resume();
                            initBgMusic();
                        } else {
                            if (bgMusicNode) {
                                try { bgMusicNode.stop(); } catch(e) {}
                                bgMusicNode = null;
                            }
                        }
                    },
                    get isEnabled() { return soundEnabled; }
                };
            }

            // Improved Sound generation functions
            generateBubbleSound() {
                const sampleRate = 44100;
                const duration = 0.15;
                const samples = new Float32Array(sampleRate * duration);
                
                for (let i = 0; i < samples.length; i++) {
                    const t = i / sampleRate;
                    // Create a soft bubble sound with multiple frequencies
                    const freq1 = 150 + Math.sin(t * 8) * 30;
                    const freq2 = 350 + Math.sin(t * 12) * 80;
                    
                    samples[i] = 0.4 * (
                        Math.sin(2 * Math.PI * freq1 * t) * Math.exp(-6 * t) +
                        Math.sin(2 * Math.PI * freq2 * t) * Math.exp(-10 * t)
                    );
                }
                
                return samples;
            }

            generatePourSound() {
                const sampleRate = 44100;
                const duration = 0.6;
                const samples = new Float32Array(sampleRate * duration);
                
                for (let i = 0; i < samples.length; i++) {
                    const t = i / sampleRate;
                    // Create a realistic pouring sound with noise and varying frequency
                    const noise = (Math.random() * 0.15) * Math.exp(-5 * t);
                    const freq = 250 + Math.sin(t * 15) * 80;
                    
                    samples[i] = 0.4 * (
                        Math.sin(2 * Math.PI * freq * t) * Math.exp(-2 * t) +
                        noise * Math.exp(-4 * t)
                    );
                }
                
                return samples;
            }

            generateSuccessSound() {
                const sampleRate = 44100;
                const duration = 1.5;
                const samples = new Float32Array(sampleRate * duration);
                
                // Create a magical success sound with ascending frequencies and harmonics
                for (let i = 0; i < samples.length; i++) {
                    const t = i / sampleRate;
                    const baseFreq = 200 + t * 300; // Ascending base frequency
                    
                    samples[i] = 0.5 * (
                        Math.sin(2 * Math.PI * baseFreq * t) * Math.exp(-1.5 * t) +
                        0.6 * Math.sin(2 * Math.PI * baseFreq * 1.5 * t) * Math.exp(-2 * t) +
                        0.4 * Math.sin(2 * Math.PI * baseFreq * 2 * t) * Math.exp(-2.5 * t) +
                        0.2 * Math.sin(2 * Math.PI * baseFreq * 3 * t) * Math.exp(-3 * t)
                    );
                }
                
                return samples;
            }

            generateFailSound() {
                const sampleRate = 44100;
                const duration = 0.4;
                const samples = new Float32Array(sampleRate * duration);
                
                // Create a soft "wrong" sound with descending frequency
                for (let i = 0; i < samples.length; i++) {
                    const t = i / sampleRate;
                    const freq = 350 - t * 300; // Descending frequency
                    
                    samples[i] = 0.3 * Math.sin(2 * Math.PI * freq * t) * Math.exp(-6 * t);
                }
                
                return samples;
            }

            generateBackgroundMusic() {
                const sampleRate = 44100;
                const duration = 15; // 15 seconds loop
                const samples = new Float32Array(sampleRate * duration);
                
                // Create a calm, magical background melody
                for (let i = 0; i < samples.length; i++) {
                    const t = i / sampleRate;
                    
                    // Calming melody with multiple harmonics
                    const melody = 
                        0.12 * Math.sin(2 * Math.PI * 220 * t) + // A3
                        0.1 * Math.sin(2 * Math.PI * 277 * t) +  // C#4
                        0.08 * Math.sin(2 * Math.PI * 330 * t) + // E4
                        0.06 * Math.sin(2 * Math.PI * 440 * t) + // A4
                        0.04 * Math.sin(2 * Math.PI * 554 * t);  // C#5
                    
                    // Add a gentle, magical arpeggio
                    const arpeggio = 
                        0.05 * Math.sin(2 * Math.PI * 440 * t * Math.sin(t * 0.5)) +
                        0.03 * Math.sin(2 * Math.PI * 523 * t * Math.sin(t * 0.7));
                    
                    samples[i] = (melody + arpeggio) * 0.25;
                }
                
                return samples;
            }

            // --- Data Management ---
            saveProgress() {
                const progress = {
                    gems: this.gameState.gems,
                    stars: this.gameState.stars,
                    unlockedWorlds: this.gameState.unlockedWorlds,
                    completedLevels: this.gameState.completedLevels,
                };
                localStorage.setItem('colorSortGameProgress', JSON.stringify(progress));
            }

            loadProgress() {
                const progress = JSON.parse(localStorage.getItem('colorSortGameProgress'));
                if (progress) {
                    this.gameState.gems = progress.gems || 0;
                    this.gameState.stars = progress.stars || 0;
                    this.gameState.unlockedWorlds = progress.unlockedWorlds || ['Ø­ÙŠÙˆØ§Ù†Ø§Øª', 'ÙÙˆØ§ÙƒÙ‡'];
                    this.gameState.completedLevels = progress.completedLevels || [];
                }
            }
            
            // --- UI Update ---
            updateHeaderUI() {
                this.DOM.gems.textContent = this.gameState.gems;
                this.DOM.stars.textContent = this.gameState.stars;
            }

            showModal(modalToShow) {
                this.DOM.modalContainer.classList.remove('opacity-0', 'pointer-events-none');
                [this.DOM.levelStartModal, this.DOM.successModal, this.DOM.gameOverModal].forEach(modal => {
                    modal.classList.add('hidden');
                });
                modalToShow.classList.remove('hidden');
                setTimeout(() => {
                    modalToShow.classList.remove('scale-95');
                }, 10);
            }
            
            hideAllModals() {
                this.DOM.modalContainer.classList.add('opacity-0', 'pointer-events-none');
                [this.DOM.levelStartModal, this.DOM.successModal, this.DOM.gameOverModal].forEach(m => {
                     m.classList.add('hidden', 'scale-95');
                });
            }

            // --- Screen Management ---
            showLevelSelection() {
                this.DOM.gameScreen.classList.add('hidden');
                this.DOM.levelSelection.innerHTML = '';
                this.DOM.levelSelection.classList.remove('hidden');

                Object.keys(this.levels).forEach(worldName => {
                    const isUnlocked = this.gameState.unlockedWorlds.includes(worldName);
                    const worldContainer = document.createElement('div');
                    worldContainer.className = `glass-effect rounded-2xl p-6 mb-8 ${isUnlocked ? 'hover:border-blue-400 transition-all duration-300' : 'opacity-60'}`;
                    
                    let worldLevelsHTML = '';
                    this.levels[worldName].forEach((level, index) => {
                        const levelId = `${worldName}-${index}`;
                        const isCompleted = this.gameState.completedLevels.includes(levelId);
                        const difficultyStars = 'â˜…'.repeat(level.difficulty);
                        
                        worldLevelsHTML += `
                            <button data-level-id="${levelId}" class="level-btn relative w-20 h-20 sm:w-24 sm:h-24 rounded-2xl flex flex-col items-center justify-center font-bold text-lg transition-all duration-300
                                ${isUnlocked ? 'bg-gray-800 hover:bg-blue-600 hover:scale-105 neon-glow' : 'bg-gray-900 cursor-not-allowed'}
                                ${isCompleted ? 'border-2 border-yellow-400' : 'border-2 border-gray-600'}" 
                                ${!isUnlocked ? 'disabled' : ''}>
                                <span class="text-2xl mb-1">${level.word}</span>
                                <span class="text-xs text-yellow-300">${difficultyStars}</span>
                                ${isCompleted ? '<span class="absolute -top-2 -right-2 text-2xl">â­</span>' : ''}
                            </button>
                        `;
                    });

                    worldContainer.innerHTML = `
                        <h2 class="text-3xl font-bold mb-4 flex items-center gap-3">
                            ${!isUnlocked ? 'ğŸ”’' : 'ğŸŒ'} ${worldName}
                            ${isUnlocked ? `<span class="text-sm font-normal bg-blue-600 px-3 py-1 rounded-full">${this.levels[worldName].length} Ù…Ø³ØªÙˆÙŠØ§Øª</span>` : ''}
                        </h2>
                        <div class="flex flex-wrap justify-center gap-4">
                            ${worldLevelsHTML}
                        </div>
                    `;
                    this.DOM.levelSelection.appendChild(worldContainer);
                });

                document.querySelectorAll('.level-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const [world, levelIndex] = btn.dataset.levelId.split('-');
                        this.prepareLevel(world, parseInt(levelIndex));
                    });
                });
            }

            prepareLevel(world, levelIndex) {
                this.gameState.currentLevel = { world, levelIndex };
                const level = this.levels[world][levelIndex];
                
                document.getElementById('startWord').textContent = level.word;
                document.getElementById('startMeaning').textContent = level.meaning;
                document.getElementById('startSentence').textContent = `Ù…Ø«Ø§Ù„: "${level.sentence}"`;
                this.soundManager.play('click');
                this.showModal(this.DOM.levelStartModal);
            }
            
            startLevel() {
                this.hideAllModals();
                this.DOM.levelSelection.classList.add('hidden');
                this.DOM.gameScreen.classList.remove('hidden');

                this.gameState.isPouring = false;
                this.gameState.selectedBottleIndex = null;
                this.gameState.timeLeft = this.config.baseLevelTime;
                this.gameState.moves = 0;
                this.DOM.moves.textContent = '0';

                const { world, levelIndex } = this.gameState.currentLevel;
                const level = this.levels[world][levelIndex];
                
                // Calculate max moves based on difficulty
                this.gameState.maxMoves = level.word.length * 2 + level.difficulty * 3;
                
                this.DOM.currentLevelDisplay.textContent = `${world} - ${levelIndex + 1}`;
                this.DOM.targetWord.textContent = level.word;
                this.setupBottles(level.word);
                this.renderBottles();
                this.updateProgress();
                this.startTimer();
            }
            
            setupBottles(word) {
                const targetLetters = [...new Set(word.split(''))];
                const numTargetBottles = targetLetters.length;
                const numExtraBottles = 2 + Math.floor(word.length / 3);
                const totalFilledBottles = numTargetBottles + Math.min(3, Math.floor(word.length / 2));

                let allColors = [];
                word.split('').forEach(letter => {
                    for (let i = 0; i < this.config.bottleCapacity; i++) {
                        allColors.push(letter);
                    }
                });
                
                // Shuffle colors
                for (let i = allColors.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allColors[i], allColors[j]] = [allColors[j], allColors[i]];
                }
                
                this.gameState.bottleContents = [];
                for (let i = 0; i < totalFilledBottles; i++) {
                    this.gameState.bottleContents.push([]);
                }
                
                // Distribute colors into bottles
                let colorIndex = 0;
                for (let i = 0; i < allColors.length; i++) {
                     this.gameState.bottleContents[i % totalFilledBottles].push(allColors[i]);
                }
                
                // Add empty bottles
                for (let i = 0; i < numExtraBottles; i++) {
                    this.gameState.bottleContents.push([]);
                }
            }
            
            renderBottles() {
                this.DOM.bottlesArea.innerHTML = '';
                this.gameState.bottleContents.forEach((content, index) => {
                    const bottleContainer = document.createElement('div');
                    bottleContainer.className = 'flex flex-col items-center';
                    
                    const bottleEl = document.createElement('div');
                    bottleEl.className = 'bottle';
                    bottleEl.dataset.index = index;
                    if(this.gameState.selectedBottleIndex === index) {
                        bottleEl.classList.add('selected');
                    }

                    const bottleBody = document.createElement('div');
                    bottleBody.className = 'bottle-body';

                    const bottleNeck = document.createElement('div');
                    bottleNeck.className = 'bottle-neck';

                    const liquidStack = document.createElement('div');
                    liquidStack.className = 'liquid-stack';

                    content.forEach(letter => {
                        const liquidUnit = document.createElement('div');
                        liquidUnit.className = 'liquid-unit';
                        liquidUnit.style.backgroundColor = this.colorMap[letter] || '#333';
                        liquidUnit.textContent = letter;
                        liquidStack.appendChild(liquidUnit);
                    });
                    
                    bottleBody.appendChild(liquidStack);
                    bottleEl.appendChild(bottleBody);
                    bottleEl.appendChild(bottleNeck);
                    
                    bottleContainer.appendChild(bottleEl);
                    
                    // Add bottle number
                    const bottleNumber = document.createElement('div');
                    bottleNumber.className = 'mt-2 text-sm text-gray-300';
                    bottleNumber.textContent = `Ù‚Ø§Ø±ÙˆØ±Ø© ${index + 1}`;
                    bottleContainer.appendChild(bottleNumber);
                    
                    this.DOM.bottlesArea.appendChild(bottleContainer);
                    
                    bottleEl.addEventListener('click', () => this.handleBottleClick(index));
                });
            }

            handleBottleClick(index) {
                if (this.gameState.isPouring) return;
                this.soundManager.play('click');
                
                if (this.gameState.selectedBottleIndex === null) {
                    if (this.gameState.bottleContents[index].length > 0) {
                        this.gameState.selectedBottleIndex = index;
                        document.querySelector(`[data-index='${index}']`).classList.add('selected');
                    }
                } else {
                    if (this.gameState.selectedBottleIndex !== index) {
                        this.pour(this.gameState.selectedBottleIndex, index);
                    }
                    const oldSelection = this.gameState.selectedBottleIndex;
                    this.gameState.selectedBottleIndex = null;
                    document.querySelector(`[data-index='${oldSelection}']`)?.classList.remove('selected');
                }
            }
            
            pour(fromIndex, toIndex) {
                const fromBottle = this.gameState.bottleContents[fromIndex];
                const toBottle = this.gameState.bottleContents[toIndex];
                
                if (fromBottle.length === 0) return;
                
                const colorToMove = fromBottle[fromBottle.length - 1];
                
                if (toBottle.length > 0 && toBottle[toBottle.length - 1] !== colorToMove) {
                    this.soundManager.play('fail');
                    this.createParticles(fromIndex, 5, this.colorMap[colorToMove] || '#333');
                    return;
                }
                if (toBottle.length >= this.config.bottleCapacity) {
                    this.soundManager.play('fail');
                    this.createParticles(fromIndex, 5, this.colorMap[colorToMove] || '#333');
                    return;
                }

                this.gameState.isPouring = true;
                this.gameState.moves++;
                this.DOM.moves.textContent = this.gameState.moves;
                
                const fromBottleEl = document.querySelector(`[data-index='${fromIndex}']`);
                const toBottleEl = document.querySelector(`[data-index='${toIndex}']`);
                
                fromBottleEl.classList.add('pour-animation');
                this.soundManager.play('pour');
                
                // Create liquid transfer effect
                this.createLiquidTransfer(fromBottleEl, toBottleEl, this.colorMap[colorToMove] || '#333');
                
                // Logic to move the color units
                const unitsToMove = [];
                for (let i = fromBottle.length - 1; i >= 0; i--) {
                    if (fromBottle[i] === colorToMove) {
                        unitsToMove.unshift(fromBottle[i]);
                    } else {
                        break;
                    }
                }

                // Check if there is space in the target bottle
                if (toBottle.length + unitsToMove.length > this.config.bottleCapacity) {
                    this.gameState.isPouring = false;
                    fromBottleEl.classList.remove('pour-animation');
                    this.soundManager.play('fail');
                    return;
                }
                
                setTimeout(() => {
                    fromBottle.splice(fromBottle.length - unitsToMove.length, unitsToMove.length);
                    toBottle.push(...unitsToMove);
                    
                    this.renderBottles();
                    this.gameState.isPouring = false;
                    this.updateProgress();
                    this.checkWinCondition();
                }, 600);
            }
            
            createLiquidTransfer(fromEl, toEl, color) {
                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                
                const transferEl = document.createElement('div');
                transferEl.className = 'liquid-transfer';
                transferEl.style.backgroundColor = color;
                transferEl.style.left = `${fromRect.left + fromRect.width / 2 - 30}px`;
                transferEl.style.top = `${fromRect.top + fromRect.height - 50}px`;
                
                document.body.appendChild(transferEl);
                
                // Animate transfer
                setTimeout(() => {
                    transferEl.style.left = `${toRect.left + toRect.width / 2 - 30}px`;
                    transferEl.style.top = `${toRect.top + toRect.height - 30}px`;
                }, 300);
                
                // Remove element after animation
                setTimeout(() => {
                    if (transferEl.parentNode) {
                        transferEl.parentNode.removeChild(transferEl);
                    }
                }, 1000);
            }
            
            createParticles(bottleIndex, count, color) {
                const bottleEl = document.querySelector(`[data-index='${bottleIndex}']`);
                const rect = bottleEl.getBoundingClientRect();
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.backgroundColor = color;
                    particle.style.left = `${rect.left + rect.width / 2}px`;
                    particle.style.top = `${rect.top + rect.height - 20}px`;
                    
                    document.body.appendChild(particle);
                    
                    // Random direction and distance
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 50;
                    const duration = 0.5 + Math.random() * 0.5;
                    
                    // Animate particle
                    particle.style.transition = `all ${duration}s ease-out`;
                    setTimeout(() => {
                        particle.style.left = `${rect.left + rect.width / 2 + Math.cos(angle) * distance}px`;
                        particle.style.top = `${rect.top + rect.height - 20 + Math.sin(angle) * distance}px`;
                        particle.style.opacity = '0';
                    }, 10);
                    
                    // Remove particle after animation
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, duration * 1000 + 100);
                }
            }
            
            updateProgress() {
                const targetWord = this.DOM.targetWord.textContent;
                let correctBottles = 0;
                
                for (const bottle of this.gameState.bottleContents) {
                    if (bottle.length === this.config.bottleCapacity && new Set(bottle).size === 1) {
                        correctBottles++;
                    }
                }
                
                const progress = Math.min(100, (correctBottles / targetWord.length) * 100);
                this.DOM.progressFill.style.width = `${progress}%`;
                this.DOM.progressText.textContent = `${Math.round(progress)}%`;
            }
            
            checkWinCondition() {
                const targetWord = this.DOM.targetWord.textContent;
                
                // Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø£ÙˆÙ„Ù‰: Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙˆØ§Ø±ÙŠØ± Ø¥Ù…Ø§ Ù…ÙƒØªÙ…Ù„Ø© Ø£Ùˆ ÙØ§Ø±ØºØ©.
                for (const bottle of this.gameState.bottleContents) {
                    const isComplete = bottle.length === this.config.bottleCapacity && new Set(bottle).size === 1;
                    const isEmpty = bottle.length === 0;
                    
                    if (!isEmpty && !isComplete) {
                        return;
                    }
                }

                // Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Ø¨Ù†Ø§Ø¡ Ø§Ù„ÙƒÙ„Ù…Ø© Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ø±ÙŠØ± Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©.
                const sortedLetters = [];
                for (const bottle of this.gameState.bottleContents) {
                    if (bottle.length > 0) {
                        sortedLetters.push(bottle[0]);
                    }
                }
                
                const formedWord = sortedLetters.join('');
                
                if (formedWord === targetWord) {
                    this.levelComplete();
                }
            }
            
            levelComplete() {
                clearInterval(this.gameState.timer);
                this.soundManager.play('success');
                
                // Create celebration particles
                this.createCelebrationParticles();
                
                const gemsEarned = 15 + Math.floor(this.gameState.timeLeft / 10) + (this.gameState.moves <= this.gameState.maxMoves ? 10 : 0);
                const starsEarned = this.gameState.timeLeft > (this.config.baseLevelTime * 0.8) ? 3 : 
                                  this.gameState.timeLeft > (this.config.baseLevelTime * 0.5) ? 2 : 1;
                
                this.gameState.gems += gemsEarned;
                this.gameState.stars += starsEarned;
                
                const {world, levelIndex} = this.gameState.currentLevel;
                const levelId = `${world}-${levelIndex}`;
                if (!this.gameState.completedLevels.includes(levelId)) {
                    this.gameState.completedLevels.push(levelId);
                }

                const currentWorldLevels = this.levels[world];
                if (levelIndex === currentWorldLevels.length - 1) {
                    const worldNames = Object.keys(this.levels);
                    const currentWorldIndex = worldNames.indexOf(world);
                    if(currentWorldIndex + 1 < worldNames.length) {
                        const nextWorld = worldNames[currentWorldIndex + 1];
                        if(!this.gameState.unlockedWorlds.includes(nextWorld)){
                            this.gameState.unlockedWorlds.push(nextWorld);
                        }
                    }
                }
                
                this.saveProgress();
                this.updateHeaderUI();
                
                document.getElementById('completedWord').textContent = this.levels[world][levelIndex].word;
                document.getElementById('gemsEarned').textContent = `+${gemsEarned}`;
                document.getElementById('starsEarned').textContent = `+${starsEarned}`;
                document.getElementById('movesCount').textContent = this.gameState.moves;
                document.getElementById('timeLeft').textContent = this.gameState.timeLeft;
                
                setTimeout(() => this.showModal(this.DOM.successModal), 1000);
            }
            
            createCelebrationParticles() {
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        const sparkle = document.createElement('div');
                        sparkle.className = 'success-sparkle';
                        sparkle.style.left = `${Math.random() * window.innerWidth}px`;
                        sparkle.style.top = `${Math.random() * window.innerHeight}px`;
                        sparkle.style.animationDelay = `${Math.random() * 0.5}s`;
                        
                        document.body.appendChild(sparkle);
                        
                        // Remove sparkle after animation
                        setTimeout(() => {
                            if (sparkle.parentNode) {
                                sparkle.parentNode.removeChild(sparkle);
                            }
                        }, 1200);
                    }, i * 100);
                }
            }
            
            startTimer() {
                clearInterval(this.gameState.timer);
                this.DOM.timer.textContent = this.gameState.timeLeft;
                this.DOM.timer.parentElement.classList.remove('text-yellow-400', 'text-red-400', 'animate-ping');

                this.gameState.timer = setInterval(() => {
                    this.gameState.timeLeft--;
                    this.DOM.timer.textContent = this.gameState.timeLeft;
                    if (this.gameState.timeLeft <= 10) {
                         this.DOM.timer.parentElement.classList.add('text-yellow-400', 'animate-ping');
                    }
                    if (this.gameState.timeLeft <= 5) {
                         this.DOM.timer.parentElement.classList.remove('text-yellow-400');
                         this.DOM.timer.parentElement.classList.add('text-red-400');
                    }
                    if (this.gameState.timeLeft <= 0) {
                        this.gameOver();
                    }
                }, 1000);
            }

            gameOver() {
                clearInterval(this.gameState.timer);
                this.soundManager.play('fail');
                this.showModal(this.DOM.gameOverModal);
            }

            resetLevel() {
                clearInterval(this.gameState.timer);
                this.startLevel();
            }
            
            provideHint() {
                if (this.gameState.gems < this.config.hintCost) {
                    alert("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø¬ÙˆØ§Ù‡Ø± ÙƒØ§ÙÙŠØ©!");
                    return;
                }

                this.gameState.gems -= this.config.hintCost;
                this.updateHeaderUI();
                this.saveProgress();

                for(let i=0; i < this.gameState.bottleContents.length; i++){
                    const fromBottle = this.gameState.bottleContents[i];
                    if(fromBottle.length === 0 || (new Set(fromBottle).size === 1 && fromBottle.length === this.config.bottleCapacity)) continue;

                    const topColor = fromBottle[fromBottle.length-1];
                    let unitsToMoveCount = 0;
                    for(let k = fromBottle.length -1; k >= 0; k--){
                        if(fromBottle[k] === topColor) unitsToMoveCount++; else break;
                    }

                    for(let j=0; j < this.gameState.bottleContents.length; j++){
                        if(i === j) continue;
                        const toBottle = this.gameState.bottleContents[j];
                        if(toBottle.length + unitsToMoveCount <= this.config.bottleCapacity && (toBottle.length === 0 || toBottle[toBottle.length-1] === topColor)){
                            const bottles = document.querySelectorAll('.bottle');
                            bottles[i].classList.add('selected');
                            setTimeout(() => { bottles[j].classList.add('selected'); }, 500);
                            setTimeout(() => {
                               bottles[i]?.classList.remove('selected');
                               bottles[j]?.classList.remove('selected');
                            }, 1500);
                            return;
                        }
                    }
                }
            }

            bindEvents() {
                this.DOM.startLevelBtn.addEventListener('click', () => this.startLevel());
                this.DOM.backBtn.addEventListener('click', () => {
                    clearInterval(this.gameState.timer);
                    this.showLevelSelection();
                });
                this.DOM.resetBtn.addEventListener('click', () => this.resetLevel());
                this.DOM.retryBtn.addEventListener('click', () => {
                    this.hideAllModals();
                    this.resetLevel();
                });
                this.DOM.nextLevelBtn.addEventListener('click', () => {
                    this.hideAllModals();
                    const {world, levelIndex} = this.gameState.currentLevel;
                    const worldLevels = this.levels[world];
                    
                    if(levelIndex + 1 < worldLevels.length){
                        this.prepareLevel(world, levelIndex + 1);
                    } else {
                         const worldNames = Object.keys(this.levels);
                         const currentWorldIndex = worldNames.indexOf(world);
                         if(currentWorldIndex + 1 < worldNames.length){
                             this.prepareLevel(worldNames[currentWorldIndex+1], 0);
                         } else {
                             this.showLevelSelection();
                             alert('ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! Ù„Ù‚Ø¯ Ø£ÙƒÙ…Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª!');
                         }
                    }
                });
                
                this.DOM.soundToggle.addEventListener('click', () => {
                    const willBeEnabled = !this.soundManager.isEnabled;
                    this.soundManager.toggle(willBeEnabled);
                    const iconPath = willBeEnabled
                        ? "M10 2a1 1 0 00-1 1v14a1 1 0 002 0V3a1 1 0 00-1-1zM5 6a1 1 0 00-1 1v6a1 1 0 002 0V7a1 1 0 00-1-1zm10 0a1 1 0 00-1 1v6a1 1 0 002 0V7a1 1 0 00-1-1z" // volume up
                        : "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293 1.293a1 1 0 01-1.414-1.414L13.586 10l-1.293-1.293a1 1 0 010-1.414z"; // volume off
                    this.DOM.soundIconPath.setAttribute('d', iconPath);
                });
                
                this.DOM.speakBtn.addEventListener('click', () => {
                    if ('speechSynthesis' in window) {
                        const textToSpeak = this.DOM.targetWord.textContent;
                        const utterance = new SpeechSynthesisUtterance(textToSpeak);
                        utterance.lang = 'ar-SA';
                        utterance.rate = 0.8;
                        speechSynthesis.speak(utterance);
                    } else {
                        alert('Ø¹Ø°Ø±Ù‹Ø§ØŒ Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ù†Ø·Ù‚ Ø§Ù„ÙƒÙ„Ù…Ø§Øª.');
                    }
                });
                
                this.DOM.hintBtn.addEventListener('click', () => this.provideHint());
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.game = new ProfessionalColorSortGame();
        });
    </script>
</body>
</html>