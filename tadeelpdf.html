
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>محرر PDF المحترف</title>
    <!-- pdf-lib and fontkit -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js"></script>
    <!-- pdf.js for rendering PDF content -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";</script>
    <!-- Signature Pad -->
    <script src="https://unpkg.com/signature_pad@4.1.5/dist/signature_pad.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #4a6bff; --secondary-color: #00c9a7; --background-start: #121212;
            --background-end: #1e1e1e; --text-color: #f5f5f5; --container-bg: #2d2d2d;
            --container-shadow: rgba(0, 0, 0, 0.5); --input-bg: #424242; --input-border: #616161;
            --input-text: #ffffff; --success-color: #28a745; --danger-color: #dc3545;
            --warning-color: #ffc107; --info-color: #17a2b8; --border-radius: 10px;
            --box-shadow: 0 12px 30px var(--container-shadow); --button-text-color: #ffffff;
            --canvas-border: #616161; --toolbar-bg: #3a3a3a; --footer-bg: #222; --footer-text: #aaa;
            --selected-color: var(--warning-color); --highlight-color: rgba(255, 255, 0, 0.3);
            --text-highlight-color: #ffff00; --stamp-color: #ff4081;
        }
        html { box-sizing: border-box; font-size: 16px; }
        *, *:before, *:after { box-sizing: inherit; }
        body {
            font-family: 'Cairo', sans-serif; display: flex; flex-direction: column; justify-content: space-between;
            align-items: center; min-height: 100vh; margin: 0; padding: 10px;
            background: linear-gradient(135deg, var(--background-start), var(--background-end));
            color: var(--text-color); direction: rtl; line-height: 1.6; user-select: none;
        }
        .editor-container {
            background-color: var(--container-bg); padding: 20px; border-radius: var(--border-radius);
            box-shadow: var(--box-shadow); text-align: center; max-width: 95%; width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 20px;
        }
        h1 {
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text; background-clip: text; color: transparent;
            margin-bottom: 20px; font-weight: 700; font-size: 1.6rem;
        }
        #pdfInput { display: none; }
        .file-label {
            display: inline-block; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--button-text-color); padding: 10px 20px; border-radius: 8px; cursor: pointer;
            font-size: 0.9rem; transition: all .3s ease; margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3); border: none;
        }
        .file-label:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0, 123, 255, 0.4); }
        #fileInfoDisplay { margin-top: 5px; margin-bottom: 15px; font-size: 0.85em; color: #bdc3c7; min-height: 1em;}
        #editorArea { display: none; margin-top: 15px; }
        #mainControls { display: flex; justify-content: space-between; align-items: center; margin-bottom:10px; flex-wrap: wrap; gap: 10px;}
        #toolbar {
            background-color: var(--toolbar-bg); padding: 8px; border-radius: var(--border-radius);
            display: flex; justify-content: center; align-items: center; gap: 8px; flex-wrap: wrap;
            border: 1px solid var(--input-border);
        }
        .tool-button, .action-button, .mode-button {
            background-color: var(--primary-color); color: white; border: none; padding: 8px 10px;
            border-radius: 5px; cursor: pointer; transition: all 0.3s; font-family: 'Cairo', sans-serif;
            font-size: 0.85rem; line-height: 1; display: flex; align-items: center; gap: 5px;
        }
        .tool-button i, .action-button i, .mode-button i { margin-left: 5px; }
        .tool-button:hover, .tool-button.active, .action-button:hover, .mode-button:hover {
            background-color: var(--secondary-color); transform: translateY(-1px);
        }
        .action-button:disabled, .tool-button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.7;}
        .action-button.danger { background-color: var(--danger-color); }
        .action-button.danger:hover { background-color: #c82333; }
        .action-button.success { background-color: var(--success-color); }
        .action-button.success:hover { background-color: #218838; }
        .action-button.info { background-color: var(--info-color); }
        .action-button.info:hover { background-color: #138496; }

        #toolOptions {
            padding: 8px; background-color: var(--input-bg); margin-bottom: 10px; border-radius:8px;
            display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap; font-size: 0.8rem;
        }
        #toolOptions label, #toolOptions input, #toolOptions select { color: var(--text-color); }
        #toolOptions input[type="color"] { padding: 0; height: 25px; width: 25px; border-radius: 5px; vertical-align: middle; cursor: pointer;}
        #toolOptions input[type="text"], #toolOptions input[type="number"], #toolOptions select {
            padding: 4px; background-color: var(--container-bg); border: 1px solid var(--input-border);
            border-radius: 5px; font-size: 0.8rem; min-width: 60px;
        }
        #toolOptions input[type="range"] { width: 80px; }
        #pageNavigation {
            display: flex; justify-content: space-between; align-items: center; padding: 8px;
            background-color: var(--toolbar-bg); border-radius:8px; margin-bottom: 10px;
        }
        #pageNavigation button { font-size: 0.85rem; }
        #pageIndicator { font-weight: bold; font-size: 0.9em; }
        #canvasContainer {
            width: 100%; max-width: 800px; margin: 10px auto; border: 2px solid var(--canvas-border);
            background-color: #808080; /* Neutral background for pdf.js canvas */
            position: relative; overflow: auto; /* aspect-ratio set by JS */ max-height: 65vh;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        /* Canvas for PDF.js rendering */
        #pdfRenderCanvas {
            display: block; /* Will be set by JS */
            /* width: 100%; height: 100%; /* Let JS control this based on PDF page size and scale */
        }
        /* Canvas for annotations, overlaying the PDF render canvas */
        #annotationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            /* width and height will be set to match pdfRenderCanvas */
            cursor: crosshair; /* Default cursor */
        }

        #annotationCanvas.text-tool-cursor { cursor: text; }
        #annotationCanvas.move-tool-cursor { cursor: grab; }
        #annotationCanvas.moving-tool-cursor { cursor: grabbing; }
        #annotationCanvas.highlight-tool-cursor { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'><rect x='0' y='7' width='16' height='2' fill='yellow' opacity='0.7'/></svg>") 8 8, auto; }
        #annotationCanvas.stamp-tool-cursor { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'><path fill='%23ff4081' d='M12,3A3,3 0 0,0 9,6A3,3 0 0,0 12,9A3,3 0 0,0 15,6A3,3 0 0,0 12,3M12,12C7,12 3,15.36 3,19.5V21H21V19.5C21,15.36 16.97,12 12,12Z'/></svg>") 12 24, auto; }

        #outputBaseFilename {
            display: block; width: calc(100% - 30px); padding: 8px 12px; margin: 15px auto;
            border: 1px solid var(--input-border); border-radius: 8px; font-size: 0.9rem;
            background-color: var(--input-bg); color: var(--input-text); transition: border 0.3s;
        }
        #outputBaseFilename:focus { border-color: var(--primary-color); outline: none; }
        #saveBtn { font-size: 1rem; padding: 12px 30px; margin-top: 10px; }
        #statusDiv { margin-top: 5px; font-weight: 700; min-height: 1.3em; font-size: 0.9rem;}
        .spinner {
            display: inline-block; border: 3px solid rgba(255, 255, 255, 0.2);
            width: 16px; height: 16px; border-radius: 50%; border-left-color: var(--primary-color);
            animation: spin 1s linear infinite; margin-left: 8px; vertical-align: middle;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        footer { font-size: 0.8em; margin-top: 20px; text-align: center; color: var(--footer-text); }
        footer a { color: var(--secondary-color); text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        /* Context menu */
        .context-menu {
            position: absolute; background-color: var(--container-bg); border: 1px solid var(--input-border);
            border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 1000;
            display: none; flex-direction: column; min-width: 150px;
        }
        .context-menu button {
            background: none; border: none; color: var(--text-color); padding: 8px 12px;
            text-align: right; cursor: pointer; font-family: 'Cairo', sans-serif;
            transition: background-color 0.2s;
        }
        .context-menu button:hover { background-color: var(--primary-color); }
        .context-menu button i { margin-left: 8px; }
        .context-menu .separator { height: 1px; background-color: var(--input-border); margin: 4px 0; }

        /* Zoom controls */
        #zoomControls {
            position: absolute; top: 10px; left: 10px; background-color: var(--toolbar-bg);
            border-radius: 5px; padding: 5px; display: flex; flex-direction: column; gap: 5px;
            z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #zoomControls button {
            background-color: var(--primary-color); color: white; border: none;
            width: 30px; height: 30px; border-radius: 3px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        #zoomControls button:hover { background-color: var(--secondary-color); }
        #zoomLevel { text-align: center; font-size: 0.8em; color: var(--text-color); }

        /* Layers panel */
        #layersPanel {
            position: absolute; top: 10px; right: 10px; background-color: var(--toolbar-bg);
            border-radius: 5px; padding: 10px; width: 200px; max-height: 300px;
            overflow-y: auto; z-index: 10; box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
        }
        #layersPanel h3 {
            margin-top: 0; margin-bottom: 10px; color: var(--text-color); font-size: 1em;
            border-bottom: 1px solid var(--input-border); padding-bottom: 5px;
        }
        .layer-item {
            display: flex; align-items: center; padding: 5px; border-radius: 3px;
            margin-bottom: 3px; cursor: pointer; transition: background-color 0.2s;
        }
        .layer-item:hover { background-color: rgba(255,255,255,0.1); }
        .layer-item.selected { background-color: var(--primary-color); }
        .layer-item .layer-visibility { margin-left: 5px; cursor: pointer; }
        .layer-item .layer-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
        }
        [data-tooltip]:hover::after {
            content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%;
            transform: translateX(-50%); background-color: #333; color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 0.8em; white-space: nowrap;
            z-index: 10000; margin-bottom: 5px; /* Increased z-index */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            body { padding: 20px; }
            .editor-container { padding: 25px; max-width: 90%;}
            h1 { font-size: 2rem; margin-bottom: 25px; }
            .file-label { padding: 12px 25px; font-size: 1rem; margin-bottom: 15px; }
            #fileInfoDisplay { font-size: 0.9em; margin-bottom: 20px; }
            #toolbar { padding: 10px; gap: 10px; }
            .tool-button, .action-button, .mode-button { padding: 10px 15px; font-size: 0.9rem;}
            #toolOptions { padding: 10px; gap: 15px; font-size: 0.9rem; }
            #toolOptions input[type="color"] { height: 30px; width: 30px;}
            #toolOptions input[type="text"], #toolOptions input[type="number"], #toolOptions select { padding: 6px; font-size:0.9rem; }
            #pageNavigation { padding: 10px; }
            #canvasContainer { margin: 15px auto; max-height: 70vh; }
            #outputBaseFilename { padding: 10px 15px; font-size: 0.95rem; }
            #saveBtn { font-size: 1.1rem; padding: 14px 35px; }
            #statusDiv { font-size: 1rem;}
        }

        @media (max-width: 600px) {
            #mainControls { flex-direction: column; }
            #toolbar, #actionsBar { width: 100%; justify-content: center; }
            #toolOptions { flex-direction: column; align-items: flex-start; }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>
    <button onclick="window.location.href='index.html'" 
  style="
    all: unset;
    position: fixed;
    top: 21px;
    left: 20px;
         font-size: 30px;
         color: #b7b63c;
         text-shadow: 1px 1px 1px #52484a;
    cursor: pointer;
    justify-content: center;
    z-index: 9999;">
      <i class="fas fa-home" > </i> 
</button>
    <div class="editor-container">
        <h1>محرر PDF المحترف</h1>
<h2>هذه الاداة قيد التجربة</h2>
        <label for="pdfInput" class="file-label" data-tooltip="اختر ملف PDF لتحريره">
            <i class="fas fa-file-pdf"></i> اختر ملف PDF
        </label>
        <input type="file" id="pdfInput" accept="application/pdf">
        <span id="fileInfoDisplay">لم يتم اختيار ملف.</span>

        <div id="editorArea">
            <div id="mainControls">
                <div id="toolbar">
                    <button class="tool-button" id="selectTool" data-tooltip="أداة التحديد (V)"><i class="fas fa-mouse-pointer"></i> تحديد</button>
                    <button class="tool-button" id="textTool" data-tooltip="إضافة نص (T)"><i class="fas fa-font"></i> نص</button>
                    <button class="tool-button" id="highlightTool" data-tooltip="إضافة تضليل"><i class="fas fa-highlighter"></i> تضليل</button>
                    <button class="tool-button" id="rectTool" data-tooltip="إضافة مستطيل (R)"><i class="fas fa-vector-square"></i> مستطيل</button>
                    <button class="tool-button" id="circleTool" data-tooltip="إضافة دائرة"><i class="far fa-circle"></i> دائرة</button>
                    <button class="tool-button" id="lineTool" data-tooltip="إضافة خط (L)"><i class="fas fa-minus"></i> خط</button>
                    <button class="tool-button" id="arrowTool" data-tooltip="إضافة سهم"><i class="fas fa-arrow-right"></i> سهم</button>
                    <button class="tool-button" id="freehandTool" data-tooltip="رسم حر (P)"><i class="fas fa-pencil-alt"></i> رسم</button>
                    <button class="tool-button" id="signatureTool" data-tooltip="إضافة توقيع"><i class="fas fa-signature"></i> توقيع</button>
                    <button class="tool-button" id="stampTool" data-tooltip="إضافة ختم"><i class="fas fa-stamp"></i> ختم</button>
                    <button class="tool-button" id="imageTool" data-tooltip="إضافة صورة (I)"><i class="fas fa-image"></i> صورة</button>
                    <input type="file" id="imageUpload" accept="image/png, image/jpeg, image/svg+xml" style="display:none;">
                    <input type="file" id="signatureUpload" accept="image/png, image/jpeg" style="display:none;">
                    <button class="tool-button" id="eraserTool" data-tooltip="ممحاة (E)"><i class="fas fa-eraser"></i> ممحاة</button>
                    <button class="tool-button" id="layersTool" data-tooltip="إدارة الطبقات"><i class="fas fa-layer-group"></i> طبقات</button>
                </div>
                <div id="actionsBar">
                    <button class="action-button" id="undoBtn" data-tooltip="تراجع (Ctrl+Z)"><i class="fas fa-undo"></i></button>
                    <button class="action-button" id="redoBtn" data-tooltip="إعادة (Ctrl+Y)"><i class="fas fa-redo"></i></button>
                    <button class="action-button danger" id="deleteBtn" data-tooltip="حذف العنصر المحدد (Del)"><i class="fas fa-trash-alt"></i></button>
                    <button class="action-button info" id="clearPageBtn" data-tooltip="مسح تعديلات الصفحة"><i class="fas fa-broom"></i></button>
                </div>
            </div>

            <div id="toolOptions">
                <div id="textOptionsContainer" class="options-panel" style="display:none;">
                    <label for="textColor">لون النص:</label> <input type="color" id="textColor" value="#000000">
                    <label for="fontSize">حجم الخط (نقطة):</label> <input type="number" id="fontSize" value="12" min="1" max="100">
                    <label for="fontSelector">الخط:</label>
                    <select id="fontSelector">
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times-Roman">Times New Roman</option>
                        <option value="Courier">Courier</option>
                        <option value="Cairo">Cairo (يتطلب التضمين)</option>
                    </select>
                    <label for="textAlign">المحاذاة:</label>
                    <select id="textAlign">
                        <option value="right">يمين</option>
                        <option value="center">وسط</option>
                        <option value="left">يسار</option>
                    </select>
                </div>
                <div id="highlightOptionsContainer" class="options-panel" style="display:none;">
                    <label for="highlightColor">لون التضليل:</label> <input type="color" id="highlightColor" value="#FFFF00">
                    <label for="highlightOpacity">الشفافية:</label> <input type="range" id="highlightOpacity" min="0.1" max="1" step="0.05" value="0.3">
                </div>
                <div id="shapeOptionsContainer" class="options-panel" style="display:none;">
                    <label for="fillColor">لون التعبئة:</label> <input type="color" id="fillColor" value="#FF0000">
                    <label for="strokeColor">لون الحد/الخط:</label> <input type="color" id="strokeColor" value="#000000">
                    <label for="strokeWidth">سمك الحد/الخط (نقطة):</label> <input type="number" id="strokeWidth" value="2" min="0" max="20">
                    <label for="shapeOpacity">الشفافية:</label> <input type="range" id="shapeOpacity" min="0.05" max="1" step="0.05" value="1">
                    <label for="lineStyle">نمط الخط:</label>
                    <select id="lineStyle">
                        <option value="solid">متصل</option>
                        <option value="dashed">متقطع</option>
                        <option value="dotted">منقط</option>
                    </select>
                </div>
                <div id="freehandOptionsContainer" class="options-panel" style="display:none;">
                    <label for="freehandColor">لون الرسم:</label> <input type="color" id="freehandColor" value="#0000FF">
                    <label for="freehandWidth">سمك الرسم (بكسل):</label> <input type="number" id="freehandWidth" value="3" min="1" max="20">
                </div>
                <div id="signatureOptionsContainer" class="options-panel" style="display:none;">
                    <label for="signatureColor">لون التوقيع:</label> <input type="color" id="signatureColor" value="#000000">
                    <label for="signatureWidth">سمك التوقيع (بكسل):</label> <input type="number" id="signatureWidth" value="2" min="1" max="10">
                    <button class="mode-button" id="uploadSignatureBtn"><i class="fas fa-upload"></i> رفع توقيع</button>
                    <button class="mode-button" id="clearSignaturePadBtn" style="display:none;"><i class="fas fa-eraser"></i> مسح اللوحة</button>
                </div>
                <div id="stampOptionsContainer" class="options-panel" style="display:none;">
                    <label for="stampType">نوع الختم:</label>
                    <select id="stampType">
                        <option value="approved">موافق</option>
                        <option value="rejected">مرفوض</option>
                        <option value="confidential">سري</option>
                        <option value="draft">مسودة</option>
                        <option value="custom">مخصص</option>
                    </select>
                    <label for="stampColor">لون الختم:</label> <input type="color" id="stampColor" value="#FF4081">
                    <label for="stampText">نص مخصص:</label> <input type="text" id="stampText" placeholder="أدخل النص" style="display:none;">
                </div>
            </div>

            <div id="pageNavigation">
                <button id="prevPageBtn" class="action-button" disabled><i class="fas fa-arrow-right"></i> السابق</button>
                <span id="pageIndicator">صفحة - / -</span>
                <button id="nextPageBtn" class="action-button" disabled>التالي <i class="fas fa-arrow-left"></i></button>
                <button id="addPageBtn" class="action-button info" data-tooltip="إضافة صفحة جديدة"><i class="fas fa-plus"></i> صفحة</button>
                <button id="deletePageBtn" class="action-button danger" data-tooltip="حذف الصفحة الحالية"><i class="fas fa-minus"></i> حذف</button>
            </div>

            <div id="canvasContainer">
                <div id="zoomControls">
                    <button id="zoomInBtn" data-tooltip="تكبير (Ctrl++)"><i class="fas fa-search-plus"></i></button>
                    <button id="zoomOutBtn" data-tooltip="تصغير (Ctrl+-)"><i class="fas fa-search-minus"></i></button>
                    <button id="zoomFitBtn" data-tooltip="ملائمة للشاشة"><i class="fas fa-expand"></i></button>
                    <div id="zoomLevel">100%</div>
                </div>
                <canvas id="pdfRenderCanvas"></canvas>
                <canvas id="annotationCanvas"></canvas>
                <!-- Signature Pad Canvas (optional, can use annotationCanvas directly) -->
                <canvas id="signaturePadCanvas" style="position: absolute; top:0; left:0; display:none; background-color: rgba(255,255,255,0.5); z-index: 100;"></canvas>
            </div>

            <div id="layersPanel">
                <h3><i class="fas fa-layer-group"></i> الطبقات</h3>
                <div id="layersList"></div>
                <button class="mode-button" id="addLayerBtn" style="margin-top: 10px;"><i class="fas fa-plus"></i> إضافة طبقة</button>
            </div>
        </div>

        <input type="text" id="outputBaseFilename" placeholder="الاسم الجديد للملف (اختياري)">
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button id="saveBtn" class="action-button success" disabled><i class="fas fa-save"></i> حفظ PDF</button>
            <button id="saveCopyBtn" class="action-button info" disabled><i class="fas fa-copy"></i> حفظ نسخة</button>
            <button id="printBtn" class="action-button" disabled><i class="fas fa-print"></i> طباعة</button>
        </div>
        <div id="statusDiv"></div>
    </div>
    <footer>
        <p>© 2025 جميع الحقوق محفوظة لموقع <a href="index.html">المعلم المرشد</a>. تصميم وتطوير    .</p>
    </footer>

    <!-- Context Menu -->
    <div class="context-menu" id="objectContextMenu">
        <button id="cmCut"><i class="fas fa-cut"></i> قص</button>
        <button id="cmCopy"><i class="fas fa-copy"></i> نسخ</button>
        <button id="cmPaste"><i class="fas fa-paste"></i> لصق</button>
        <button id="cmDuplicate"><i class="fas fa-clone"></i> تكرار</button>
        <div class="separator"></div>
        <button id="cmBringToFront"><i class="fas fa-arrow-up"></i> للأمام</button>
        <button id="cmSendToBack"><i class="fas fa-arrow-down"></i> للخلف</button>
        <div class="separator"></div>
        <button id="cmDelete" class="danger"><i class="fas fa-trash-alt"></i> حذف</button>
    </div>

    <script>
        // Ensure libraries are loaded
        if (typeof window.PDFLib === 'undefined' || typeof window.fontkit === 'undefined' || typeof window.pdfjsLib === 'undefined' || typeof window.SignaturePad === 'undefined') {
            const missing = [];
            if (typeof window.PDFLib === 'undefined') missing.push('pdf-lib');
            if (typeof window.fontkit === 'undefined') missing.push('fontkit');
            if (typeof window.pdfjsLib === 'undefined') missing.push('pdf.js');
            if (typeof window.SignaturePad === 'undefined') missing.push('SignaturePad');
            alert(`خطأ فادح: المكتبات التالية غير محملة: ${missing.join(', ')}. لا يمكن تشغيل المحرر.`);
            document.body.innerHTML = `<h1 style='color:red; text-align:center; margin-top: 50px;'>خطأ في تحميل المكتبات الأساسية (${missing.join(', ')}). يرجى التحقق من اتصالك بالإنترنت وتحديث الصفحة.</h1>`;
            throw new Error("Core libraries not loaded: " + missing.join(', '));
        }

        const { PDFDocument, rgb, StandardFonts, degrees, TextAlignment, LineCapStyle, LineJoinStyle } = window.PDFLib;
        const { FontKit } = window; // fontkit is automatically registered by pdf-lib if loaded.
        const { GlobalWorkerOptions, getDocument } = window.pdfjsLib;
        const { SignaturePad } = window;


        // --- DOM Elements ---
        const pdfInput = document.getElementById('pdfInput');
        const fileInfoDisplay = document.getElementById('fileInfoDisplay');
        const editorArea = document.getElementById('editorArea');
        const outputBaseFilenameInput = document.getElementById('outputBaseFilename');
        const saveBtn = document.getElementById('saveBtn');
        const saveCopyBtn = document.getElementById('saveCopyBtn');
        const printBtn = document.getElementById('printBtn');
        const statusDiv = document.getElementById('statusDiv');

        const toolbarButtons = document.querySelectorAll('#toolbar .tool-button');
        const toolOptionsContainer = document.getElementById('toolOptions');
        const optionsPanels = document.querySelectorAll('.options-panel');

        const selectToolBtn = document.getElementById('selectTool');
        const textToolBtn = document.getElementById('textTool');
        const highlightToolBtn = document.getElementById('highlightTool');
        const rectToolBtn = document.getElementById('rectTool');
        const circleToolBtn = document.getElementById('circleTool');
        const lineToolBtn = document.getElementById('lineTool');
        const arrowToolBtn = document.getElementById('arrowTool');
        const freehandToolBtn = document.getElementById('freehandTool');
        const signatureToolBtn = document.getElementById('signatureTool');
        const stampToolBtn = document.getElementById('stampTool');
        const imageToolBtn = document.getElementById('imageTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const layersToolBtn = document.getElementById('layersTool');
        const imageUploadInput = document.getElementById('imageUpload');
        const signatureUploadInput = document.getElementById('signatureUpload');
        const uploadSignatureBtn = document.getElementById('uploadSignatureBtn');
        const clearSignaturePadBtn = document.getElementById('clearSignaturePadBtn');

        const textColorInput = document.getElementById('textColor');
        const fontSizeInput = document.getElementById('fontSize');
        const fontSelector = document.getElementById('fontSelector');
        const textAlignSelect = document.getElementById('textAlign');
        const highlightColorInput = document.getElementById('highlightColor');
        const highlightOpacityInput = document.getElementById('highlightOpacity');
        const fillColorInput = document.getElementById('fillColor');
        const strokeColorInput = document.getElementById('strokeColor');
        const strokeWidthInput = document.getElementById('strokeWidth');
        const shapeOpacityInput = document.getElementById('shapeOpacity');
        const lineStyleSelect = document.getElementById('lineStyle');
        const freehandColorInput = document.getElementById('freehandColor');
        const freehandWidthInput = document.getElementById('freehandWidth');
        const signatureColorInput = document.getElementById('signatureColor');
        const signatureWidthInput = document.getElementById('signatureWidth');
        const stampTypeSelect = document.getElementById('stampType');
        const stampColorInput = document.getElementById('stampColor');
        const stampTextInput = document.getElementById('stampText');

        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const addPageBtn = document.getElementById('addPageBtn');
        const deletePageBtn = document.getElementById('deletePageBtn');
        const pageIndicator = document.getElementById('pageIndicator');
        const clearPageBtn = document.getElementById('clearPageBtn');

        const canvasContainer = document.getElementById('canvasContainer');
        const pdfRenderCanvas = document.getElementById('pdfRenderCanvas'); // For pdf.js
        const annotationCanvas = document.getElementById('annotationCanvas'); // For our drawings
        const signaturePadCanvas = document.getElementById('signaturePadCanvas'); // Dedicated for signature pad
        const renderCtx = pdfRenderCanvas.getContext('2d');
        const annotationCtx = annotationCanvas.getContext('2d');
        let sigPadInstance = null; // Will hold the SignaturePad instance


        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomFitBtn = document.getElementById('zoomFitBtn');
        const zoomLevelDisplay = document.getElementById('zoomLevel');
        const layersPanel = document.getElementById('layersPanel');
        const layersList = document.getElementById('layersList');
        const addLayerBtn = document.getElementById('addLayerBtn');

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const deleteBtn = document.getElementById('deleteBtn');

        const objectContextMenu = document.getElementById('objectContextMenu');
        const cmCutBtn = document.getElementById('cmCut');
        const cmCopyBtn = document.getElementById('cmCopy');
        const cmPasteBtn = document.getElementById('cmPaste');
        const cmDuplicateBtn = document.getElementById('cmDuplicate');
        const cmBringToFrontBtn = document.getElementById('cmBringToFront');
        const cmSendToBackBtn = document.getElementById('cmSendToBack');
        const cmDeleteBtn = document.getElementById('cmDelete');

        const helpBtn = document.getElementById('helpBtn');

        // --- State ---
        let originalPdfFile = null; // Store the original File object
        let pdfJsDoc = null; // From pdf.js
        let pdfLibDoc = null; // From pdf-lib, loaded from originalPdfFile.arrayBuffer() for saving
        let pdfLibDocArrayBuffer = null; // Stores arrayBuffer for pdfLibDoc for 'save copy'

        let totalPages = 0;
        let currentPageNum = 1;
        let currentRenderTask = null; // To cancel ongoing pdf.js render
        let currentPdfJsPage = null; // Store the current pdf.js page object

        let currentCanvasScale = 1.0; // Scale applied to canvas by pdf.js rendering viewport
                                     // This is different from annotation object's internal scale/zoom perception

        let activeTool = 'select';
        let isProcessing = false;
        let isDrawing = false;
        let currentDrawingPoints = []; // For freehand, line, etc. In page coordinates.
        let dragStartX, dragStartY; // In page coordinates
        let selectedObject = null;
        let resizeHandle = null; // 'tl', 'tr', 'br', 'bl', 't', 'r', 'b', 'l', 'rotate'
        let clipboard = null; // For copy/paste objects

        const RESIZE_HANDLE_SIZE = 8; // In screen pixels
        const MIN_OBJECT_SIZE = 5; // In page PDF points

        let editsPerPage = []; // Array of arrays, one for each page. Stores annotation objects.
        let undoStack = [];
        let redoStack = [];
        let embeddedFonts = {}; // For pdf-lib saving. Key: fontName, Value: PDFEmbeddedFont object
        let layers = [];
        let currentLayerId = 'default';
        let copiedObject = null;

        const ZOOM_STEP = 0.2;
        const MIN_ZOOM_SCALE = 0.25;
        const MAX_ZOOM_SCALE = 3.0; // Max scale for pdf.js rendering

        const DEFAULT_FONT_PATH = 'https://fonts.gstatic.com/s/cairo/v28/SLXGc1nY6HkvalIkTpu0xg.woff2';
        const STAMP_TEXTS = {
            approved: 'موافق', rejected: 'مرفوض', confidential: 'سري',
            draft: 'مسودة', custom: 'نص مخصص'
        };

        // --- Utility Functions ---
        function generateId() { return Math.random().toString(36).substr(2, 9); }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : { r:0, g:0, b:0 };
        }

        // Converts canvas/mouse event coordinates to PDF page coordinates (origin top-left for annotations)
        function getPdfPageCoordinates(event) {
            const rect = annotationCanvas.getBoundingClientRect(); // Use annotation canvas
            // Mouse event (clientX, clientY) is relative to viewport.
            // rect.left, rect.top are canvas position relative to viewport.
            // (event.clientX - rect.left) is x on canvas in display pixels.
            // Divide by currentCanvasScale to get PDF point units (assuming 1 PDF point = 1 CSS pixel at scale 1).
            // pdf.js viewport scale already handles the devicePixelRatio.
            return {
                x: (event.clientX - rect.left) / currentCanvasScale,
                y: (event.clientY - rect.top) / currentCanvasScale
            };
        }


        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['بايت', 'كيلوبايت', 'ميجابايت', 'جيجابايت'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        function varGet(varName, fallback) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || fallback;
        }


        // --- History (Undo/Redo) ---
        function saveStateForUndo(forceSave = false) {
            const currentStateString = JSON.stringify({ edits: editsPerPage, layers: layers, currentLayer: currentLayerId });
            if (undoStack.length > 0 && undoStack[undoStack.length - 1] === currentStateString && !forceSave) {
                return;
            }
            redoStack = [];
            undoStack.push(currentStateString);
            if (undoStack.length > 50) undoStack.shift();
            updateHistoryButtons();
        }

        undoBtn.addEventListener('click', () => {
            if (undoStack.length > 0) {
                const currentState = JSON.stringify({ edits: editsPerPage, layers: layers, currentLayer: currentLayerId });
                redoStack.push(currentState);
                const prevState = undoStack.pop();
                const state = JSON.parse(prevState);
                editsPerPage = state.edits;
                layers = state.layers;
                currentLayerId = state.currentLayer;
                selectedObject = null;
                renderAnnotations(); // Only re-render annotations
                updateHistoryButtons();
                updateLayersPanel();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                const currentState = JSON.stringify({ edits: editsPerPage, layers: layers, currentLayer: currentLayerId });
                undoStack.push(currentState);
                const nextState = redoStack.pop();
                const state = JSON.parse(nextState);
                editsPerPage = state.edits;
                layers = state.layers;
                currentLayerId = state.currentLayer;
                selectedObject = null;
                renderAnnotations();
                updateHistoryButtons();
                updateLayersPanel();
            }
        });

        function updateHistoryButtons() {
            undoBtn.disabled = undoStack.length === 0 || isProcessing;
            redoBtn.disabled = redoStack.length === 0 || isProcessing;
        }

        // --- Main Application Logic ---
        async function initializeEditor() {
            pdfInput.addEventListener("change", handleFileSelect);
            setupToolListeners();
            setupCanvasListeners(); // For annotation canvas
            setupActionListeners();
            setupContextMenu();
            setupZoomControls();
            setActiveTool('select');
            updateUIState();
        }

        async function handleFileSelect(e) {
            // Reset state
            originalPdfFile = null; pdfJsDoc = null; pdfLibDoc = null; pdfLibDocArrayBuffer = null;
            totalPages = 0; currentPageNum = 1; currentCanvasScale = 1.0;
            editsPerPage = []; undoStack = []; redoStack = []; selectedObject = null;
            embeddedFonts = {}; layers = []; currentLayerId = 'default'; copiedObject = null;
            statusDiv.innerHTML = ''; editorArea.style.display = 'none';
            updateUIState();

            const file = e.target.files[0];
            if (!file) { fileInfoDisplay.textContent = 'لم يتم اختيار ملف.'; return; }
            if (file.type !== 'application/pdf') {
                fileInfoDisplay.textContent = 'خطأ: الملف المختار ليس بصيغة PDF.';
                fileInfoDisplay.style.color = 'var(--danger-color)'; return;
            }
            originalPdfFile = file; // Store the original File object

            isProcessing = true;
            statusDiv.innerHTML = 'جاري تحميل الملف... <div class="spinner"></div>';
            updateUIState();

            try {
                const arrayBuffer = await originalPdfFile.arrayBuffer();
                pdfLibDocArrayBuffer = arrayBuffer.slice(0); // Keep a copy for pdf-lib later

                // Load with pdf.js for rendering
                const loadingTask = getDocument({ data: arrayBuffer });
                pdfJsDoc = await loadingTask.promise;
                totalPages = pdfJsDoc.numPages;
                editsPerPage = Array(totalPages).fill(null).map(() => []);

                // Load with pdf-lib for modifications and saving (can be deferred to save time)
                // pdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer, { fontkit: window.fontkit, updateMetadata: false });
                // pdfLibDoc.registerFontkit(window.fontkit); // Redundant if fontkit global

                setupLayers(); // Initialize layers after PDF basic info is loaded

                // Pre-embed common fonts for pdf-lib (can be done on demand too)
                // This step is deferred to savePdf to use the correct pdfLibDoc instance (original or copy)
                
                statusDiv.innerHTML = 'تم تحميل الملف بنجاح.';
                statusDiv.style.color = 'var(--success-color)';
                editorArea.style.display = 'block';
                currentPageNum = 1;
                await renderPdfPage(currentPageNum);

            } catch (err) {
                console.error("Error loading PDF:", err);
                statusDiv.textContent = `خطأ في تحميل الملف: ${err.message}. يرجى التأكد أن الملف غير تالف.`;
                statusDiv.style.color = 'var(--danger-color)';
                originalPdfFile = null; pdfJsDoc = null; pdfLibDoc = null;
            } finally {
                isProcessing = false;
                updateUIState();
                updateHistoryButtons();
                e.target.value = null;
            }
        }

        async function renderPdfPage(pageNum, scaleToFit = true) {
            if (!pdfJsDoc || pageNum < 1 || pageNum > totalPages || isProcessing) return;
            isProcessing = true; // Prevent interactions during page render

            if (currentRenderTask) {
                currentRenderTask.cancel(); // Cancel previous render if any
                currentRenderTask = null;
            }

            try {
                currentPdfJsPage = await pdfJsDoc.getPage(pageNum);
                let viewport;
                if (scaleToFit) { // Typically on first load or zoomFit
                    const desiredWidth = canvasContainer.clientWidth > 0 ? canvasContainer.clientWidth : 800;
                    const unscaledViewport = currentPdfJsPage.getViewport({ scale: 1 });
                    currentCanvasScale = desiredWidth / unscaledViewport.width;
                    currentCanvasScale = Math.min(currentCanvasScale, MAX_ZOOM_SCALE); // Cap max zoom
                    currentCanvasScale = Math.max(currentCanvasScale, MIN_ZOOM_SCALE); // Cap min zoom
                    viewport = currentPdfJsPage.getViewport({ scale: currentCanvasScale });
                } else { // Use existing currentCanvasScale (e.g. for zoom in/out)
                     viewport = currentPdfJsPage.getViewport({ scale: currentCanvasScale });
                }

                pdfRenderCanvas.height = viewport.height;
                pdfRenderCanvas.width = viewport.width;
                annotationCanvas.height = viewport.height;
                annotationCanvas.width = viewport.width;

                if (sigPadInstance) { // Adjust signature pad canvas if active
                    signaturePadCanvas.width = viewport.width;
                    signaturePadCanvas.height = viewport.height;
                }


                const renderContext = {
                    canvasContext: renderCtx,
                    viewport: viewport
                };
                currentRenderTask = currentPdfJsPage.render(renderContext);
                await currentRenderTask.promise;
                currentRenderTask = null;

                renderAnnotations(); // Draw annotations on top

            } catch (err) {
                if (err.name === 'RenderingCancelledException') {
                    console.log('Page rendering cancelled.');
                } else {
                    console.error('Error rendering page:', err);
                    statusDiv.textContent = `خطأ في عرض الصفحة ${pageNum}: ${err.message}`;
                    statusDiv.style.color = 'var(--danger-color)';
                }
            } finally {
                isProcessing = false;
                updateUIState();
                updateZoomDisplay();
            }
        }


        // Renders annotations from editsPerPage onto annotationCanvas
        function renderAnnotations() {
            if (!currentPdfJsPage || currentPageNum < 1) return;
            annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

            const pageEdits = editsPerPage[currentPageNum - 1] || [];
            const sortedEdits = [...pageEdits].sort((a, b) => {
                const layerA = layers.find(l => l.id === a.layerId) || { order: 0, visible: true };
                const layerB = layers.find(l => l.id === b.layerId) || { order: 0, visible: true };
                if (layerA.order !== layerB.order) return layerA.order - layerB.order;
                return pageEdits.indexOf(a) - pageEdits.indexOf(b);
            });

            sortedEdits.forEach(obj => {
                if (!obj) return; // Skip if somehow a null/undefined obj got in
                const layer = layers.find(l => l.id === obj.layerId);
                if (!obj.visible || (layer && !layer.visible)) return;
                drawAnnotationObject(obj);
            });

            if (selectedObject) {
                drawSelectionHandles(selectedObject);
            }
        }

        // Draws a single annotation object onto annotationCtx
        // Object coordinates (obj.x, obj.y, etc.) are in PDF page points (origin top-left for annotations)
        function drawAnnotationObject(obj) {
            annotationCtx.save();
            annotationCtx.globalAlpha = obj.opacity === undefined ? 1 : obj.opacity;

            // Convert PDF page points to canvas display pixels for drawing
            const x = obj.x * currentCanvasScale;
            const y = obj.y * currentCanvasScale;
            let w = obj.width * currentCanvasScale;
            let h = obj.height * currentCanvasScale;

            // Apply object's own rotation if any
            if (obj.rotation) {
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                annotationCtx.translate(centerX, centerY);
                annotationCtx.rotate(obj.rotation); // obj.rotation in radians
                annotationCtx.translate(-centerX, -centerY);
            }


            switch (obj.type) {
                case 'text':
                    annotationCtx.fillStyle = obj.colorHex;
                    // obj.fontSize is in PDF points. For canvas, scale it.
                    const canvasFontSize = obj.fontSize * currentCanvasScale;
                    annotationCtx.font = `${obj.fontWeight || 'normal'} ${obj.fontStyle || 'normal'} ${canvasFontSize}px ${obj.fontName === 'Cairo' ? 'Cairo, sans-serif' : obj.fontName}`;

                    let textX = x;
                    if (obj.align === 'center') {
                        annotationCtx.textAlign = 'center';
                        textX = x + w / 2;
                    } else if (obj.align === 'left') {
                        annotationCtx.textAlign = 'left';
                        textX = x;
                    } else { // Default right for Arabic
                        annotationCtx.textAlign = 'right';
                        textX = x + w;
                    }
                    annotationCtx.textBaseline = 'top'; // Draw from top
                    annotationCtx.fillText(obj.content, textX, y);
                    break;

                case 'highlight':
                    annotationCtx.fillStyle = obj.colorHex;
                    // Opacity already set by globalAlpha
                    annotationCtx.fillRect(x, y, w, h);
                    break;

                case 'rect':
                    if (obj.fillColorHex && obj.fillColorHex !== 'transparent') {
                        annotationCtx.fillStyle = obj.fillColorHex;
                        annotationCtx.fillRect(x, y, w, h);
                    }
                    if (obj.strokeColorHex && obj.strokeWidth > 0) {
                        setCanvasLineStyle(annotationCtx, obj.lineStyle, obj.strokeWidth * currentCanvasScale);
                        annotationCtx.strokeStyle = obj.strokeColorHex;
                        annotationCtx.lineWidth = obj.strokeWidth * currentCanvasScale;
                        annotationCtx.strokeRect(x, y, w, h);
                    }
                    break;

                case 'circle':
                    annotationCtx.beginPath();
                    const centerX = x + w/2;
                    const centerY = y + h/2;
                    const radius = Math.min(w, h)/2;
                    annotationCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    if (obj.fillColorHex && obj.fillColorHex !== 'transparent') {
                        annotationCtx.fillStyle = obj.fillColorHex;
                        annotationCtx.fill();
                    }
                    if (obj.strokeColorHex && obj.strokeWidth > 0) {
                        setCanvasLineStyle(annotationCtx, obj.lineStyle, obj.strokeWidth * currentCanvasScale);
                        annotationCtx.strokeStyle = obj.strokeColorHex;
                        annotationCtx.lineWidth = obj.strokeWidth * currentCanvasScale;
                        annotationCtx.stroke();
                    }
                    break;

                case 'line': // Handles arrows too
                    if (!obj.points || obj.points.length < 2) break;
                    annotationCtx.beginPath();
                    const p0x = obj.points[0].x * currentCanvasScale;
                    const p0y = obj.points[0].y * currentCanvasScale;
                    const p1x = obj.points[1].x * currentCanvasScale;
                    const p1y = obj.points[1].y * currentCanvasScale;
                    annotationCtx.moveTo(p0x, p0y);
                    annotationCtx.lineTo(p1x, p1y);

                    setCanvasLineStyle(annotationCtx, obj.lineStyle, obj.strokeWidth * currentCanvasScale);
                    annotationCtx.strokeStyle = obj.strokeColorHex;
                    annotationCtx.lineWidth = obj.strokeWidth * currentCanvasScale;
                    annotationCtx.stroke();

                    if (obj.isArrow) {
                        drawCanvasArrowhead(annotationCtx, p1x, p1y, p0x, p0y,
                            obj.strokeColorHex,
                            Math.max(5, obj.strokeWidth * currentCanvasScale * 2.5) // Arrow size in canvas pixels
                        );
                    }
                    break;

                case 'freehand':
                case 'signature': // Path-based signature
                     if (obj.points && obj.points.length > 1) {
                        annotationCtx.beginPath();
                        annotationCtx.moveTo(obj.points[0].x * currentCanvasScale, obj.points[0].y * currentCanvasScale);
                        for(let i = 1; i < obj.points.length; i++) {
                            annotationCtx.lineTo(obj.points[i].x * currentCanvasScale, obj.points[i].y * currentCanvasScale);
                        }
                        annotationCtx.strokeStyle = obj.colorHex;
                        annotationCtx.lineWidth = obj.strokeWidth * currentCanvasScale; // freehandWidth is in canvas px
                        annotationCtx.lineCap = 'round';
                        annotationCtx.lineJoin = 'round';
                        annotationCtx.stroke();
                    } else if (obj.type === 'signature' && obj.imageElement) { // Image-based signature
                        annotationCtx.drawImage(obj.imageElement, x, y, w, h);
                    }
                    break;

                case 'stamp':
                    annotationCtx.beginPath();
                    const stampRadius = Math.min(w,h)/2;
                    if (obj.stampShape === 'circle') {
                        annotationCtx.arc(x + w/2, y + h/2, stampRadius, 0, Math.PI * 2);
                    } else {
                        annotationCtx.rect(x, y, w, h);
                    }
                    annotationCtx.fillStyle = obj.colorHex + '33'; // ~20% opacity fill
                    annotationCtx.fill();
                    annotationCtx.strokeStyle = obj.colorHex;
                    annotationCtx.lineWidth = Math.max(1, 2 * currentCanvasScale); // Border thickness in canvas px
                    annotationCtx.stroke();

                    annotationCtx.fillStyle = obj.colorHex;
                    const stampFontSize = Math.min(w, h) / 3; // Font size relative to stamp box in canvas px
                    annotationCtx.font = `bold ${stampFontSize}px Cairo, sans-serif`;
                    annotationCtx.textAlign = 'center';
                    annotationCtx.textBaseline = 'middle';
                    annotationCtx.fillText(obj.text, x + w/2, y + h/2);
                    break;

                case 'image':
                    if (obj.imageElement) {
                        annotationCtx.drawImage(obj.imageElement, x, y, w, h);
                    } else if (obj.imageBytes) { // Fallback if element not loaded
                        annotationCtx.strokeStyle = 'grey';
                        annotationCtx.strokeRect(x, y, w, h);
                        annotationCtx.fillStyle = 'grey';
                        annotationCtx.font = `${12 * currentCanvasScale}px Cairo`;
                        annotationCtx.textAlign = 'center';
                        annotationCtx.textBaseline = 'middle';
                        annotationCtx.fillText('صورة...', x + w/2, y + h/2);
                    }
                    break;
            }
            annotationCtx.restore();
        }

        function setCanvasLineStyle(ctx, style, lineWidth) { // lineWidth is already scaled for canvas
            ctx.setLineDash([]);
            if (style === 'dashed') {
                ctx.setLineDash([lineWidth * 2, lineWidth * 1.5]);
            } else if (style === 'dotted') {
                ctx.setLineDash([lineWidth * 0.5, lineWidth * 0.75]);
            }
        }

        function drawCanvasArrowhead(ctx, x, y, fromX, fromY, color, size) { // size is in canvas pixels
            ctx.save();
            ctx.fillStyle = color;
            const angle = Math.atan2(y - fromY, x - fromX);
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size/2.5);
            ctx.lineTo(-size * 0.8, 0);
            ctx.lineTo(-size, size/2.5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }


        function drawSelectionHandles(obj) {
            annotationCtx.save();
            // Object's own rotation
            const objX_cvs = obj.x * currentCanvasScale;
            const objY_cvs = obj.y * currentCanvasScale;
            const objW_cvs = obj.width * currentCanvasScale;
            const objH_cvs = obj.height * currentCanvasScale;

            if (obj.rotation) {
                const centerX = objX_cvs + objW_cvs / 2;
                const centerY = objY_cvs + objH_cvs / 2;
                annotationCtx.translate(centerX, centerY);
                annotationCtx.rotate(obj.rotation);
                annotationCtx.translate(-centerX, -centerY);
            }

            const handleScreenSize = RESIZE_HANDLE_SIZE; // Use screen pixels for handle display size
            const halfHandle = handleScreenSize / 2;

            annotationCtx.strokeStyle = 'rgba(74, 107, 255, 0.8)';
            annotationCtx.lineWidth = 1.5;
            annotationCtx.setLineDash([4, 2]);
            annotationCtx.strokeRect(objX_cvs - 1, objY_cvs - 1, objW_cvs + 2, objH_cvs + 2);
            annotationCtx.setLineDash([]);

            annotationCtx.fillStyle = varGet('--selected-color', '#FFC107');
            annotationCtx.strokeStyle = 'black';
            annotationCtx.lineWidth = 1;

            // Handle positions in canvas coordinates, relative to object's (potentially rotated) frame
            const handlesData = [
                { x: objX_cvs, y: objY_cvs, name: 'tl' },
                { x: objX_cvs + objW_cvs, y: objY_cvs, name: 'tr' },
                { x: objX_cvs, y: objY_cvs + objH_cvs, name: 'bl' },
                { x: objX_cvs + objW_cvs, y: objY_cvs + objH_cvs, name: 'br' }
            ];
            if (obj.type !== 'line' && obj.type !== 'freehand' && !(obj.type === 'signature' && obj.points)) { // Not for path-based objects
                 handlesData.push(
                    { x: objX_cvs + objW_cvs / 2, y: objY_cvs, name: 't' },
                    { x: objX_cvs + objW_cvs / 2, y: objY_cvs + objH_cvs, name: 'b' },
                    { x: objX_cvs, y: objY_cvs + objH_cvs / 2, name: 'l' },
                    { x: objX_cvs + objW_cvs, y: objY_cvs + objH_cvs / 2, name: 'r' }
                );
            }

            handlesData.forEach(h => {
                annotationCtx.fillRect(h.x - halfHandle, h.y - halfHandle, handleScreenSize, handleScreenSize);
                annotationCtx.strokeRect(h.x - halfHandle, h.y - halfHandle, handleScreenSize, handleScreenSize);
            });

            if (obj.type !== 'line' && obj.type !== 'freehand' && !(obj.type === 'signature' && obj.points)) {
                const rotHandleX_cvs = objX_cvs + objW_cvs / 2;
                const rotHandleY_cvs = objY_cvs - 20; // 20px above the object on screen

                annotationCtx.beginPath();
                annotationCtx.arc(rotHandleX_cvs, rotHandleY_cvs, halfHandle + 2, 0, Math.PI * 2);
                annotationCtx.fill();
                annotationCtx.stroke();
                annotationCtx.beginPath();
                annotationCtx.moveTo(rotHandleX_cvs, rotHandleY_cvs + halfHandle + 2);
                annotationCtx.lineTo(objX_cvs + objW_cvs / 2, objY_cvs);
                annotationCtx.stroke();
            }
            annotationCtx.restore();
        }

        // coords are in PDF page points. obj dimensions are also in PDF page points.
        function getResizeHandleAt(coordsPage, obj) {
            const handleSizePagePt = RESIZE_HANDLE_SIZE / currentCanvasScale; // Handle visual size in page points
            const hHalfPagePt = handleSizePagePt / 2;

            let localClickX = coordsPage.x;
            let localClickY = coordsPage.y;

            // Transform click to object's local unrotated frame
            if (obj.rotation) {
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                const dx = coordsPage.x - centerX;
                const dy = coordsPage.y - centerY;
                const angle = -obj.rotation;
                localClickX = centerX + (dx * Math.cos(angle) - dy * Math.sin(angle));
                localClickY = centerY + (dx * Math.sin(angle) + dy * Math.cos(angle));
            }

            // Check rotation handle (position relative to unrotated object)
            if (obj.type !== 'line' && obj.type !== 'freehand' && !(obj.type === 'signature' && obj.points)) {
                const rotHandlePageX = obj.x + obj.width / 2;
                const rotHandlePageY = obj.y - (20 / currentCanvasScale); // 20px on screen, converted to page points
                if (Math.sqrt(Math.pow(coordsPage.x - rotHandlePageX, 2) + Math.pow(coordsPage.y - rotHandlePageY, 2)) <= hHalfPagePt + (2 / currentCanvasScale)) {
                    return 'rotate';
                }
            }

            // Check resize handles in object's local frame
            if (isWithinPagePt(localClickX, localClickY, obj.x, obj.y, hHalfPagePt)) return 'tl';
            if (isWithinPagePt(localClickX, localClickY, obj.x + obj.width, obj.y, hHalfPagePt)) return 'tr';
            if (isWithinPagePt(localClickX, localClickY, obj.x, obj.y + obj.height, hHalfPagePt)) return 'bl';
            if (isWithinPagePt(localClickX, localClickY, obj.x + obj.width, obj.y + obj.height, hHalfPagePt)) return 'br';

            if (obj.type !== 'line' && obj.type !== 'freehand' && !(obj.type === 'signature' && obj.points)) {
                if (isWithinPagePt(localClickX, localClickY, obj.x + obj.width / 2, obj.y, hHalfPagePt)) return 't';
                if (isWithinPagePt(localClickX, localClickY, obj.x + obj.width / 2, obj.y + obj.height, hHalfPagePt)) return 'b';
                if (isWithinPagePt(localClickX, localClickY, obj.x, obj.y + obj.height / 2, hHalfPagePt)) return 'l';
                if (isWithinPagePt(localClickX, localClickY, obj.x + obj.width, obj.y + obj.height / 2, hHalfPagePt)) return 'r';
            }
            return null;
        }

        function isWithinPagePt(px, py, hx, hy, halfHandleSizePagePt) {
            return px >= hx - halfHandleSizePagePt && px <= hx + halfHandleSizePagePt &&
                   py >= hy - halfHandleSizePagePt && py <= hy + halfHandleSizePagePt;
        }


        function setupToolListeners() {
            toolbarButtons.forEach(btn => {
                btn.addEventListener('click', () => setActiveTool(btn.id.replace('Tool', '')));
            });
            stampTypeSelect.addEventListener('change', updateStampOptions);
            uploadSignatureBtn.addEventListener('click', () => signatureUploadInput.click());
            imageToolBtn.addEventListener('click', () => {
                 if(activeTool === 'image') imageUploadInput.click();
            });
            clearSignaturePadBtn.addEventListener('click', () => {
                if (sigPadInstance) sigPadInstance.clear();
                isSignatureDrawn = false; // Reset flag
            });
        }

        function updateStampOptions() {
            const type = stampTypeSelect.value;
            stampTextInput.style.display = (type === 'custom') ? 'inline-block' : 'none';
        }

        function setActiveTool(toolId) {
            if (activeTool === 'signature' && sigPadInstance) { // Cleanup signature pad if active
                signaturePadCanvas.style.display = 'none';
                sigPadInstance.off();
                // sigPadInstance = null; // Don't nullify, just hide and turn off
            }
            clearSignaturePadBtn.style.display = 'none';


            activeTool = toolId;
            if (toolId !== 'select') selectedObject = null;

            toolbarButtons.forEach(btn => btn.classList.toggle('active', btn.id === toolId + 'Tool'));
            optionsPanels.forEach(p => p.style.display = 'none');
            toolOptionsContainer.style.display = 'flex';

            if (toolId === 'text') document.getElementById('textOptionsContainer').style.display = 'flex';
            else if (toolId === 'highlight') document.getElementById('highlightOptionsContainer').style.display = 'flex';
            else if (['rect', 'circle', 'line', 'arrow'].includes(toolId)) document.getElementById('shapeOptionsContainer').style.display = 'flex';
            else if (toolId === 'freehand') document.getElementById('freehandOptionsContainer').style.display = 'flex';
            else if (toolId === 'signature') {
                document.getElementById('signatureOptionsContainer').style.display = 'flex';
                signaturePadCanvas.style.display = 'block'; // Show drawing area
                clearSignaturePadBtn.style.display = 'inline-block';
                if (!sigPadInstance) {
                    sigPadInstance = new SignaturePad(signaturePadCanvas, {
                        penColor: signatureColorInput.value,
                        minWidth: parseFloat(signatureWidthInput.value) / 2,
                        maxWidth: parseFloat(signatureWidthInput.value),
                        backgroundColor: 'rgba(255,255,255,0)', // Transparent background
                    });
                } else {
                     sigPadInstance.penColor = signatureColorInput.value;
                     sigPadInstance.minWidth = parseFloat(signatureWidthInput.value) / 2;
                     sigPadInstance.maxWidth = parseFloat(signatureWidthInput.value);
                     sigPadInstance.clear(); // Clear previous drawing when tool re-selected
                }
                isSignatureDrawn = false;
            }
            else if (toolId === 'stamp') document.getElementById('stampOptionsContainer').style.display = 'flex';
            else if (toolId === 'image') toolOptionsContainer.style.display = 'none'; // No options for image tool itself
            else toolOptionsContainer.style.display = 'none'; // For select, eraser, layers

            updateAnnotationCanvasCursor();
            renderAnnotations(); // Redraw annotations (especially if selection changed)
        }

        function updateAnnotationCanvasCursor() {
            annotationCanvas.classList.remove(
                'text-tool-cursor', 'move-tool-cursor', 'moving-tool-cursor',
                'highlight-tool-cursor', 'stamp-tool-cursor'
            );
            annotationCanvas.style.cursor = 'crosshair'; // Default

            if (activeTool === 'text') annotationCanvas.classList.add('text-tool-cursor');
            else if (activeTool === 'highlight') annotationCanvas.classList.add('highlight-tool-cursor');
            else if (activeTool === 'stamp') annotationCanvas.classList.add('stamp-tool-cursor');
            else if (activeTool === 'select') annotationCanvas.style.cursor = 'default';
            else if (activeTool === 'eraser') annotationCanvas.style.cursor = 'copy'; // Placeholder for eraser icon
        }


        function setupActionListeners() {
            prevPageBtn.addEventListener('click', () => {
                if (currentPageNum > 1) { currentPageNum--; renderPdfPage(currentPageNum); }
            });
            nextPageBtn.addEventListener('click', () => {
                if (currentPageNum < totalPages) { currentPageNum++; renderPdfPage(currentPageNum); }
            });
            addPageBtn.addEventListener('click', addNewPdfPage); // Updated function name
            deletePageBtn.addEventListener('click', deleteCurrentPdfPage); // Updated function name

            deleteBtn.addEventListener('click', deleteSelectedObject);
            clearPageBtn.addEventListener('click', clearCurrentPageAnnotations); // Clarified name

            imageUploadInput.addEventListener('change', handleImageUpload);
            signatureUploadInput.addEventListener('change', handleSignatureUpload);

            saveBtn.addEventListener('click', () => savePdfAnnotations(false)); // Updated name
            saveCopyBtn.addEventListener('click', () => savePdfAnnotations(true)); // Updated name
            printBtn.addEventListener('click', printCurrentPdf); // Updated name
            helpBtn.addEventListener('click', showHelp);

            document.addEventListener('keydown', (e) => {
                if (!pdfJsDoc || editorArea.style.display === 'none' ||
                    document.activeElement.tagName === 'INPUT' ||
                    document.activeElement.tagName === 'SELECT' ||
                    document.activeElement.tagName === 'TEXTAREA') return;

                if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                    switch (e.key.toLowerCase()) {
                        case 'v': setActiveTool('select'); e.preventDefault(); break;
                        case 't': setActiveTool('text'); e.preventDefault(); break;
                        case 'r': setActiveTool('rect'); e.preventDefault(); break;
                        case 'l': setActiveTool('line'); e.preventDefault(); break;
                        case 'p': setActiveTool('freehand'); e.preventDefault(); break;
                        case 'i': if (activeTool === 'image') imageUploadInput.click(); else setActiveTool('image'); e.preventDefault(); break;
                        case 'e': setActiveTool('eraser'); e.preventDefault(); break;
                    }
                }

                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (selectedObject) { e.preventDefault(); deleteSelectedObject(); }
                } else if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'z': e.preventDefault(); undoBtn.click(); break;
                        case 'y': e.preventDefault(); redoBtn.click(); break;
                        case 'c': if (selectedObject) { e.preventDefault(); copySelectedObject(); } break;
                        case 'x': if (selectedObject) { e.preventDefault(); cutSelectedObject(); } break;
                        case 'v': e.preventDefault(); pasteObject(); break;
                        case 'd': if (selectedObject) { e.preventDefault(); duplicateSelectedObject(); } break;
                        case '=': case '+': e.preventDefault(); zoomIn(); break;
                        case '-': e.preventDefault(); zoomOut(); break;
                        case '0': e.preventDefault(); zoomFit(); break;
                        case 's': e.preventDefault(); saveBtn.click(); break;
                    }
                } else if (e.key === 'ArrowLeft' && !e.ctrlKey && !e.metaKey) {
                     if (currentPageNum > 1) {e.preventDefault(); currentPageNum--; renderPdfPage(currentPageNum);}
                } else if (e.key === 'ArrowRight' && !e.ctrlKey && !e.metaKey) {
                     if (currentPageNum < totalPages) {e.preventDefault(); currentPageNum++; renderPdfPage(currentPageNum);}
                }
            });
        }

        function setupContextMenu() {
            annotationCanvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (!selectedObject) {
                    objectContextMenu.style.display = 'none';
                    return;
                }
                cmPasteBtn.disabled = !copiedObject;
                objectContextMenu.style.display = 'flex';
                const menuWidth = objectContextMenu.offsetWidth;
                const menuHeight = objectContextMenu.offsetHeight;
                let x = e.clientX; let y = e.clientY;
                if (x + menuWidth > window.innerWidth) x -= menuWidth;
                if (y + menuHeight > window.innerHeight) y -= menuHeight;
                objectContextMenu.style.left = `${x}px`;
                objectContextMenu.style.top = `${y}px`;
            });
            document.addEventListener('click', (e) => {
                if (objectContextMenu.style.display === 'flex' && !objectContextMenu.contains(e.target)) {
                    objectContextMenu.style.display = 'none';
                }
            });
            cmCutBtn.addEventListener('click', () => { cutSelectedObject(); objectContextMenu.style.display = 'none'; });
            cmCopyBtn.addEventListener('click', () => { copySelectedObject(); objectContextMenu.style.display = 'none'; });
            cmPasteBtn.addEventListener('click', () => { pasteObject(); objectContextMenu.style.display = 'none'; });
            cmDuplicateBtn.addEventListener('click', () => { duplicateSelectedObject(); objectContextMenu.style.display = 'none'; });
            cmBringToFrontBtn.addEventListener('click', () => { changeObjectZIndex('front'); objectContextMenu.style.display = 'none'; });
            cmSendToBackBtn.addEventListener('click', () => { changeObjectZIndex('back'); objectContextMenu.style.display = 'none'; });
            cmDeleteBtn.addEventListener('click', () => { deleteSelectedObject(); objectContextMenu.style.display = 'none'; });
        }

        function setupZoomControls() {
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            zoomFitBtn.addEventListener('click', zoomFit);
            annotationCanvas.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    if (e.deltaY < 0) zoomIn(); else zoomOut();
                }
            }, { passive: false });
        }

        function zoomIn() {
            if (currentCanvasScale >= MAX_ZOOM_SCALE) return;
            currentCanvasScale = Math.min(currentCanvasScale + ZOOM_STEP, MAX_ZOOM_SCALE);
            renderPdfPage(currentPageNum, false); // false: don't scale to fit, use new currentCanvasScale
        }
        function zoomOut() {
            if (currentCanvasScale <= MIN_ZOOM_SCALE) return;
            currentCanvasScale = Math.max(currentCanvasScale - ZOOM_STEP, MIN_ZOOM_SCALE);
            renderPdfPage(currentPageNum, false);
        }
        function zoomFit() {
            renderPdfPage(currentPageNum, true); // true: scale to fit
        }
        function updateZoomDisplay() {
            zoomLevelDisplay.textContent = `${Math.round(currentCanvasScale * 100)}%`;
        }

        function setupLayers() { /* ... (unchanged for brevity, assumed working) ... */ }
        function toggleLayersPanel() { /* ... */ }
        function updateLayersPanel() { /* ... */ }
        function addNewLayer() { /* ... */ }
        function deleteLayer(layerId) { /* ... */ }

        async function addNewPdfPage() {
            if (!pdfLibDoc) { // Ensure pdfLibDoc is loaded if not already
                if (!pdfLibDocArrayBuffer) {
                    alert("لا يوجد ملف PDF أصلي لإضافة صفحة إليه.");
                    return;
                }
                pdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer, { fontkit: window.fontkit, updateMetadata: false });
                pdfLibDoc.registerFontkit(window.fontkit);
            }
            saveStateForUndo(true);

            pdfLibDoc.addPage([612, 792]); // Add to pdf-lib doc that will be saved
                                          // pdf.js doc (pdfJsDoc) is read-only from original file.
                                          // This means the new page won't show content in editor until save & reload.
                                          // A more advanced solution would be to create a blank page in pdf.js view too.

            totalPages++; // This now refers to the count in pdfLibDoc for saving
            editsPerPage.splice(currentPageNum, 0, []); // Insert edits for new page

            // For user feedback, we might need to update the pdfJsDoc reference or simulate a new page
            // This is tricky. For now, we'll just update the number and the user will see it after save.
            statusDiv.textContent = `تمت إضافة صفحة (ستظهر بعد الحفظ). الصفحات الحالية: ${totalPages}.`;
            updateUIState(); // To update page indicator for the *target* total pages
            // Ideally, navigate to a representation of this new blank page.
            // For now, stay on current page, new page is 'virtual' until save.
        }

        async function deleteCurrentPdfPage() {
            if (!pdfLibDoc) {
                 if (!pdfLibDocArrayBuffer) { alert("لا يوجد ملف PDF أصلي لحذف صفحة منه."); return; }
                 pdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer, { fontkit: window.fontkit, updateMetadata: false });
                 pdfLibDoc.registerFontkit(window.fontkit);
            }
            if (pdfLibDoc.getPageCount() <= 1) { alert("لا يمكن حذف الصفحة الوحيدة."); return; }
            if (!confirm(`هل أنت متأكد أنك تريد حذف الصفحة ${currentPageNum} (ستُحذف نهائياً عند الحفظ)؟`)) return;

            saveStateForUndo(true);
            pdfLibDoc.removePage(currentPageNum - 1);
            totalPages = pdfLibDoc.getPageCount(); // Update based on pdfLibDoc
            editsPerPage.splice(currentPageNum - 1, 1);

            // Navigate to a valid page in the VIEW (pdfJsDoc)
            // The view's totalPages might be different now until save & reload
            const newViewPageNum = Math.min(currentPageNum, pdfJsDoc.numPages); // Stay within view bounds
            if (currentPageNum > pdfJsDoc.numPages && pdfJsDoc.numPages > 0) {
                currentPageNum = pdfJsDoc.numPages;
            } else if (pdfJsDoc.numPages === 0) { // Should not happen if delete is guarded
                currentPageNum = 1;
            }
             if (currentPageNum > totalPages) currentPageNum = totalPages; // If view page was deleted, adjust current
             if (currentPageNum < 1 && totalPages > 0) currentPageNum = 1;


            statusDiv.textContent = `تم تحديد الصفحة ${currentPageNum} للحذف عند الحفظ. الصفحات المتبقية ستكون: ${totalPages}.`;
            updateUIState();
            if (pdfJsDoc.numPages > 0) { // Re-render current or new current view page
                 await renderPdfPage(Math.max(1, Math.min(currentPageNum, pdfJsDoc.numPages)));
            } else {
                // Handle case where all viewable pages are gone (e.g. if we only had 1 page)
                editorArea.style.display = 'none';
                fileInfoDisplay.textContent = "تم حذف كل الصفحات. يرجى تحميل ملف جديد.";
            }
        }


        function clearCurrentPageAnnotations() {
            if (!pdfJsDoc || currentPageNum < 1) return;
            if (!confirm("هل أنت متأكد أنك تريد مسح جميع التعديلات من هذه الصفحة؟")) return;
            saveStateForUndo();
            editsPerPage[currentPageNum - 1] = [];
            selectedObject = null;
            renderAnnotations();
        }

        function deleteSelectedObject() { /* ... (largely unchanged, ensure it uses renderAnnotations) ... */
            if (!selectedObject || currentPageNum < 1) return;
            saveStateForUndo();
            const pageEdits = editsPerPage[currentPageNum - 1];
            const index = pageEdits.findIndex(obj => obj.id === selectedObject.id);
            if (index > -1) {
                pageEdits.splice(index, 1);
                selectedObject = null;
                renderAnnotations();
                updateUIState();
            }
        }
        function copySelectedObject() { /* ... (unchanged) ... */
            if (!selectedObject) return;
            copiedObject = JSON.parse(JSON.stringify(selectedObject));
            copiedObject.id = generateId();
            statusDiv.textContent = 'تم نسخ العنصر.';
            statusDiv.style.color = 'var(--success-color)';
            cmPasteBtn.disabled = false;
        }
        function cutSelectedObject() { /* ... (ensure saveState and renderAnnotations are called correctly) ... */
            if (!selectedObject) return;
            saveStateForUndo();
            copySelectedObject();
            deleteSelectedObject(); // This calls its own saveState & render
            statusDiv.textContent = 'تم قص العنصر.';
        }
        function pasteObject() { /* ... (ensure it uses currentLayerId and PDF page coords) ... */
            if (!copiedObject || currentPageNum < 1) return;
            saveStateForUndo();
            const newObj = JSON.parse(JSON.stringify(copiedObject));
            newObj.id = generateId();
            newObj.x += 10 / currentCanvasScale; // Offset in page points
            newObj.y += 10 / currentCanvasScale;
            newObj.layerId = currentLayerId;

            if (newObj.points) { // Offset points for path based objects
                newObj.points = newObj.points.map(p => ({ x: p.x + 10 / currentCanvasScale, y: p.y + 10 / currentCanvasScale }));
            }

            editsPerPage[currentPageNum - 1].push(newObj);
            selectedObject = newObj;
            renderAnnotations();
            updateUIState();
            // Update clipboard for next paste (daisy chain)
            copiedObject.x += 10 / currentCanvasScale;
            copiedObject.y += 10 / currentCanvasScale;
             if (copiedObject.points) {
                copiedObject.points = copiedObject.points.map(p => ({ x: p.x + 10 / currentCanvasScale, y: p.y + 10 / currentCanvasScale }));
            }
        }
        function duplicateSelectedObject() { /* ... (unchanged) ... */
            if (!selectedObject) return;
            copySelectedObject();
            pasteObject();
        }
        function changeObjectZIndex(position) { /* ... (ensure renderAnnotations) ... */
            if (!selectedObject || currentPageNum < 1) return;
            saveStateForUndo();
            const pageEdits = editsPerPage[currentPageNum - 1];
            const index = pageEdits.findIndex(obj => obj.id === selectedObject.id);
            if (index > -1) {
                const [objToMove] = pageEdits.splice(index, 1);
                if (position === 'front') pageEdits.push(objToMove);
                else pageEdits.unshift(objToMove);
                renderAnnotations();
            }
        }

        function setupCanvasListeners() { // Listeners on annotationCanvas
            annotationCanvas.addEventListener('mousedown', handleMouseDown);
            annotationCanvas.addEventListener('mousemove', handleMouseMove);
            annotationCanvas.addEventListener('mouseup', handleMouseUp);
            annotationCanvas.addEventListener('mouseleave', handleMouseLeave);
        }

        function handleMouseDown(e) {
            if (!pdfJsDoc || isProcessing || e.button !== 0 || (activeTool === 'signature' && signaturePadCanvas.style.display === 'block') ) return;

            const coordsPage = getPdfPageCoordinates(e); // Coords in PDF page points
            isDrawing = true;
            dragStartX = coordsPage.x;
            dragStartY = coordsPage.y;
            currentDrawingPoints = [{x: coordsPage.x, y: coordsPage.y}];

            if (activeTool === 'select') {
                resizeHandle = selectedObject ? getResizeHandleAt(coordsPage, selectedObject) : null;
                if (!resizeHandle) { // If not clicking a handle, try to select an object
                    const clickedObject = findObjectAt(coordsPage);
                    if (selectedObject !== clickedObject) saveStateForUndo(); // If selection changes
                    selectedObject = clickedObject;
                }
            } else if (activeTool === 'eraser') {
                const clickedObject = findObjectAt(coordsPage);
                if (clickedObject) {
                    selectedObject = clickedObject; // Select for deletion
                    deleteSelectedObject(); // This calls saveStateForUndo
                    selectedObject = null; // Deselect
                }
            } else {
                selectedObject = null; // For drawing tools, deselect any existing object
            }
            renderAnnotations(); // Redraw for selection handles or temp drawing feedback
            updateUIState();
        }

        function handleMouseMove(e) {
            if (!pdfJsDoc || (activeTool === 'signature' && signaturePadCanvas.style.display === 'block')) return;

            const coordsPage = getPdfPageCoordinates(e);

            // Cursor update for select tool when not drawing
            if (activeTool === 'select' && !isDrawing && selectedObject) {
                const handle = getResizeHandleAt(coordsPage, selectedObject);
                if (handle) {
                    if (handle === 'rotate') annotationCanvas.style.cursor = 'grab'; // Ideally a rotation cursor
                    else if (['tl', 'br'].includes(handle)) annotationCanvas.style.cursor = 'nwse-resize';
                    else if (['tr', 'bl'].includes(handle)) annotationCanvas.style.cursor = 'nesw-resize';
                    else if (['t', 'b'].includes(handle)) annotationCanvas.style.cursor = 'ns-resize';
                    else if (['l', 'r'].includes(handle)) annotationCanvas.style.cursor = 'ew-resize';
                } else if (findObjectAt(coordsPage)) {
                    annotationCanvas.style.cursor = 'grab';
                } else {
                    annotationCanvas.style.cursor = 'default';
                }
            }
            if (!isDrawing) return;


            const dxPage = coordsPage.x - dragStartX; // Delta in page points
            const dyPage = coordsPage.y - dragStartY;

            if (activeTool === 'select' && selectedObject) {
                annotationCanvas.classList.add('moving-tool-cursor');
                let needsUndoSave = false;

                if (resizeHandle === 'rotate') {
                    const centerX = selectedObject.x + selectedObject.width / 2;
                    const centerY = selectedObject.y + selectedObject.height / 2;
                    const newAngle = Math.atan2(coordsPage.y - centerY, coordsPage.x - centerX);
                    const prevAngle = Math.atan2(dragStartY - centerY, dragStartX - centerX);
                    selectedObject.rotation = (selectedObject.rotation || 0) + (newAngle - prevAngle);
                    needsUndoSave = true;
                } else if (resizeHandle) {
                    let { x, y, width, height } = selectedObject;
                    const oX = x, oY = y, oW = width, oH = height;

                    if (resizeHandle.includes('l')) { width -= dxPage; x += dxPage; }
                    if (resizeHandle.includes('r')) { width += dxPage; }
                    if (resizeHandle.includes('t')) { height -= dyPage; y += dyPage; }
                    if (resizeHandle.includes('b')) { height += dyPage; }

                    if (width < MIN_OBJECT_SIZE) {
                        if (resizeHandle.includes('l')) x = oX + oW - MIN_OBJECT_SIZE;
                        width = MIN_OBJECT_SIZE;
                    }
                    if (height < MIN_OBJECT_SIZE) {
                        if (resizeHandle.includes('t')) y = oY + oH - MIN_OBJECT_SIZE;
                        height = MIN_OBJECT_SIZE;
                    }
                     // Aspect ratio for images and shift-key for others
                    if ( (selectedObject.type === 'image' || e.shiftKey) &&
                         selectedObject.originalWidth && selectedObject.originalHeight &&
                         ['tl','tr','bl','br'].includes(resizeHandle) ) {
                        const aspectRatio = selectedObject.originalWidth / selectedObject.originalHeight;
                        if (resizeHandle === 'tl' || resizeHandle === 'tr' || resizeHandle === 'bl' || resizeHandle === 'br') {
                            if (Math.abs(dxPage) > Math.abs(dyPage * aspectRatio)) { // Width changed more
                                const newHeight = width / aspectRatio;
                                if (resizeHandle.includes('t')) y += (height - newHeight);
                                height = newHeight;
                            } else { // Height changed more
                                const newWidth = height * aspectRatio;
                                if (resizeHandle.includes('l')) x += (width - newWidth);
                                width = newWidth;
                            }
                        }
                    }


                    selectedObject.x = x; selectedObject.y = y;
                    selectedObject.width = width; selectedObject.height = height;
                    if (selectedObject.type === 'text') selectedObject.fontSize = Math.max(5, height / 1.3);
                    needsUndoSave = true;
                } else { // Move
                    selectedObject.x += dxPage;
                    selectedObject.y += dyPage;
                    if (selectedObject.points) {
                        selectedObject.points = selectedObject.points.map(p => ({ x: p.x + dxPage, y: p.y + dyPage }));
                    }
                    needsUndoSave = true;
                }
                // if (needsUndoSave) { // This will be saved on mouseup }
                dragStartX = coordsPage.x; dragStartY = coordsPage.y;
                renderAnnotations();

            } else if (activeTool === 'freehand') {
                currentDrawingPoints.push({x: coordsPage.x, y: coordsPage.y});
                renderAnnotations(); // Clear and redraw all
                // Then draw current path on top for immediate feedback
                annotationCtx.beginPath();
                annotationCtx.moveTo(currentDrawingPoints[0].x * currentCanvasScale, currentDrawingPoints[0].y * currentCanvasScale);
                currentDrawingPoints.forEach(p => annotationCtx.lineTo(p.x * currentCanvasScale, p.y * currentCanvasScale));
                annotationCtx.strokeStyle = freehandColorInput.value;
                annotationCtx.lineWidth = parseInt(freehandWidthInput.value); // freehandWidth is already canvas px
                annotationCtx.lineCap = 'round'; annotationCtx.lineJoin = 'round';
                annotationCtx.stroke();

            } else if (['line', 'arrow', 'rect', 'circle', 'highlight'].includes(activeTool)) {
                renderAnnotations(); // Redraw existing annotations
                const tempObj = { // Temp object in PDF page points
                    x: Math.min(dragStartX, coordsPage.x),
                    y: Math.min(dragStartY, coordsPage.y),
                    width: Math.abs(coordsPage.x - dragStartX),
                    height: Math.abs(coordsPage.y - dragStartY),
                    visible: true, opacity: 1, // For temp drawing
                };
                if (activeTool === 'line' || activeTool === 'arrow') {
                    tempObj.type = 'line';
                    tempObj.points = [{x: dragStartX, y: dragStartY}, {x: coordsPage.x, y: coordsPage.y}];
                    tempObj.strokeColorHex = strokeColorInput.value;
                    tempObj.strokeWidth = parseInt(strokeWidthInput.value); // in PDF points
                    tempObj.lineStyle = lineStyleSelect.value;
                    tempObj.isArrow = activeTool === 'arrow';
                    tempObj.opacity = parseFloat(shapeOpacityInput.value);
                } else if (activeTool === 'rect' || activeTool === 'circle') {
                    tempObj.type = activeTool;
                    tempObj.fillColorHex = fillColorInput.value;
                    tempObj.strokeColorHex = strokeColorInput.value;
                    tempObj.strokeWidth = parseInt(strokeWidthInput.value);
                    tempObj.lineStyle = lineStyleSelect.value;
                    tempObj.opacity = parseFloat(shapeOpacityInput.value);
                } else if (activeTool === 'highlight') {
                    tempObj.type = 'highlight';
                    tempObj.colorHex = highlightColorInput.value;
                    tempObj.opacity = parseFloat(highlightOpacityInput.value);
                }
                if (tempObj.width > 0 || tempObj.height > 0) { // Only draw if valid dimensions
                     drawAnnotationObject(tempObj); // Draw the temporary shape
                }
            }
        }

        function handleMouseUp(e) {
            if (!pdfJsDoc || !isDrawing || e.button !== 0 || (activeTool === 'signature' && signaturePadCanvas.style.display === 'block')) {
                 isDrawing = false; // Ensure reset
                 if (activeTool === 'select') annotationCanvas.classList.remove('moving-tool-cursor');
                 return;
            }
            isDrawing = false;
            annotationCanvas.classList.remove('moving-tool-cursor');
            updateAnnotationCanvasCursor();

            const coordsPage = getPdfPageCoordinates(e);
            let newObject = null;

            if (activeTool === 'select') {
                if (selectedObject && (resizeHandle || (coordsPage.x !== dragStartX || coordsPage.y !== dragStartY) ) ) {
                    saveStateForUndo(true); // Save if object was moved or resized
                }
                resizeHandle = null;
            } else if (activeTool === 'text') {
                const text = prompt("أدخل النص:");
                if (text && text.trim() !== "") {
                    const fontSizeVal = parseInt(fontSizeInput.value); // PDF Points
                    // Estimate width/height in PDF points for bounding box
                    const tempCtx = document.createElement('canvas').getContext('2d'); // Offscreen measure
                    tempCtx.font = `${fontSizeVal}px ${fontSelector.value}`; // Measure in PDF points directly
                    const textMetrics = tempCtx.measureText(text);
                    let textWidth = textMetrics.width;
                    // Actual ascent/descent would be better. This is an approximation.
                    let textHeight = fontSizeVal * 1.2; // Approx height for bounding box

                    let objX = coordsPage.x; // Default for left align
                    if (textAlignSelect.value === 'center') objX = coordsPage.x - textWidth / 2;
                    else if (textAlignSelect.value === 'right') objX = coordsPage.x - textWidth;

                    newObject = {
                        id: generateId(), type: 'text', content: text,
                        x: objX, y: coordsPage.y, // y is top for text object
                        width: textWidth, height: textHeight,
                        colorHex: textColorInput.value, fontSize: fontSizeVal,
                        fontName: fontSelector.value, align: textAlignSelect.value,
                        opacity: 1, layerId: currentLayerId, visible: true,
                        fontWeight: 'normal', fontStyle: 'normal' // Defaults
                    };
                }
            } else if (activeTool === 'highlight') {
                const w = Math.abs(coordsPage.x - dragStartX);
                const h = Math.abs(coordsPage.y - dragStartY);
                if (w > 1 && h > 1) { // Min size in page points
                    newObject = {
                        id: generateId(), type: 'highlight',
                        x: Math.min(dragStartX, coordsPage.x), y: Math.min(dragStartY, coordsPage.y),
                        width: w, height: h,
                        colorHex: highlightColorInput.value, opacity: parseFloat(highlightOpacityInput.value),
                        layerId: currentLayerId, visible: true
                    };
                }
            } else if (['rect', 'circle', 'line', 'arrow'].includes(activeTool)) {
                const width = Math.abs(coordsPage.x - dragStartX);
                const height = Math.abs(coordsPage.y - dragStartY);
                const minDim = (activeTool === 'line' || activeTool === 'arrow') ? 1 : MIN_OBJECT_SIZE;

                if (width >= minDim || height >= minDim) {
                    const baseShape = {
                        id: generateId(),
                        x: Math.min(dragStartX, coordsPage.x), y: Math.min(dragStartY, coordsPage.y),
                        width: width, height: height,
                        strokeWidth: parseInt(strokeWidthInput.value), // PDF points
                        opacity: parseFloat(shapeOpacityInput.value),
                        lineStyle: lineStyleSelect.value,
                        layerId: currentLayerId, visible: true
                    };
                    if (activeTool === 'rect' || activeTool === 'circle') {
                        baseShape.type = activeTool;
                        baseShape.fillColorHex = fillColorInput.value;
                        baseShape.strokeColorHex = strokeColorInput.value;
                    } else { // line or arrow
                        baseShape.type = 'line';
                        baseShape.points = [{x: dragStartX, y: dragStartY}, {x: coordsPage.x, y: coordsPage.y}];
                        baseShape.strokeColorHex = strokeColorInput.value;
                        baseShape.isArrow = activeTool === 'arrow';
                        // x,y,width,height become bounding box for lines
                        baseShape.x = Math.min(baseShape.points[0].x, baseShape.points[1].x);
                        baseShape.y = Math.min(baseShape.points[0].y, baseShape.points[1].y);
                        baseShape.width = Math.abs(baseShape.points[0].x - baseShape.points[1].x);
                        baseShape.height = Math.abs(baseShape.points[0].y - baseShape.points[1].y);
                    }
                    newObject = baseShape;
                }
            } else if (activeTool === 'freehand') {
                if (currentDrawingPoints.length > 1) {
                    const bounds = getPointsBounds(currentDrawingPoints); // currentDrawingPoints are page points
                    newObject = {
                        id: generateId(), type: 'freehand',
                        points: [...currentDrawingPoints],
                        x: bounds.minX, y: bounds.minY,
                        width: bounds.maxX - bounds.minX, height: bounds.maxY - bounds.minY,
                        colorHex: freehandColorInput.value,
                        strokeWidth: parseInt(freehandWidthInput.value), // This is canvas px, convert to PDF points
                                                                       // For simplicity, let's assume it's small enough
                                                                       // or adjust if it looks too thick/thin in PDF
                        opacity: 1, layerId: currentLayerId, visible: true
                    };
                }
            } else if (activeTool === 'signature') { // This is for drawn signature on sigPad
                if (sigPadInstance && !sigPadInstance.isEmpty()) {
                    isSignatureDrawn = true; // Mark that something was drawn
                     // Convert signature pad data (which is in its own canvas coords) to PDF page points
                    const data = sigPadInstance.toData(); // Array of point groups
                    let sigPoints = [];
                    data.forEach(group => group.points.forEach(p => {
                        // p.x, p.y are relative to signaturePadCanvas
                        // Need to scale them to PDF page points
                        sigPoints.push({
                            x: p.x / currentCanvasScale, // Assumes sigPadCanvas has same scale as annotationCanvas
                            y: p.y / currentCanvasScale
                        });
                    }));

                    if (sigPoints.length > 1) {
                        const bounds = getPointsBounds(sigPoints);
                        newObject = {
                            id: generateId(), type: 'signature', points: sigPoints,
                            x: bounds.minX, y: bounds.minY,
                            width: bounds.maxX - bounds.minX, height: bounds.maxY - bounds.minY,
                            colorHex: signatureColorInput.value,
                            strokeWidth: parseInt(signatureWidthInput.value), // Canvas px, like freehand
                            opacity: 1, layerId: currentLayerId, visible: true
                        };
                    }
                    sigPadInstance.clear(); // Clear pad after capturing
                    isSignatureDrawn = false;
                }
                 // Keep signature pad active until tool changes
            } else if (activeTool === 'stamp') {
                const stampType = stampTypeSelect.value;
                let stampTextVal = STAMP_TEXTS[stampType] || STAMP_TEXTS['custom'];
                if (stampType === 'custom') stampTextVal = stampTextInput.value.trim() || STAMP_TEXTS['custom'];

                if (stampTextVal) {
                    const stampSize = 80; // Default size in PDF points
                    newObject = {
                        id: generateId(), type: 'stamp',
                        x: coordsPage.x - stampSize/2, y: coordsPage.y - stampSize/2, // Centered at click
                        width: stampSize, height: stampSize,
                        colorHex: stampColorInput.value, text: stampTextVal,
                        stampShape: (stampType === 'approved' || stampType === 'rejected') ? 'circle' : 'rect',
                        opacity: 1, layerId: currentLayerId, visible: true
                    };
                }
            }

            if (newObject) { // Basic check, specific tools might have own width/height check
                 if (newObject.type !== 'line' && newObject.type !== 'arrow' && newObject.type !== 'freehand' && newObject.type !== 'signature' && (newObject.width <=0 || newObject.height <=0)) {
                    // Don't add zero-size rects, circles, etc.
                 } else {
                    saveStateForUndo(true);
                    editsPerPage[currentPageNum - 1].push(newObject);
                    selectedObject = newObject;
                 }
            }
            currentDrawingPoints = [];
            renderAnnotations(); // Final render with new object or selection change
        }

        function getPointsBounds(points) { /* ... (unchanged) ... */
            if (!points || points.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
            let minX = points[0].x, maxX = points[0].x;
            let minY = points[0].y, maxY = points[0].y;
            points.forEach(p => {
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
            });
            return { minX, maxX, minY, maxY };
        }

        function handleMouseLeave(e) {
            if (isDrawing && activeTool !== 'signature') { // Don't auto-finish signature on mouse leave
                handleMouseUp(e); // Finalize drawing if mouse leaves canvas
            }
            annotationCanvas.style.cursor = 'crosshair'; // Reset cursor
        }


        function findObjectAt(coordsPage) { // coordsPage are in PDF page points
            if (currentPageNum < 1 || !editsPerPage[currentPageNum - 1]) return null;
            const pageEdits = editsPerPage[currentPageNum - 1];

            for (let i = pageEdits.length - 1; i >= 0; i--) { // Iterate from top-most
                const obj = pageEdits[i];
                if (!obj) continue;
                const layer = layers.find(l => l.id === obj.layerId);
                if (!obj.visible || (layer && (!layer.visible || layer.locked))) continue;

                let localClickX = coordsPage.x;
                let localClickY = coordsPage.y;
                if (obj.rotation) {
                    const centerX = obj.x + obj.width / 2;
                    const centerY = obj.y + obj.height / 2;
                    const dx = coordsPage.x - centerX;
                    const dy = coordsPage.y - centerY;
                    const angle = -obj.rotation;
                    localClickX = centerX + (dx * Math.cos(angle) - dy * Math.sin(angle));
                    localClickY = centerY + (dx * Math.sin(angle) + dy * Math.cos(angle));
                }

                // BBox check in object's local (unrotated) frame
                if (localClickX >= obj.x && localClickX <= obj.x + obj.width &&
                    localClickY >= obj.y && localClickY <= obj.y + obj.height) {

                    if (obj.type === 'line' || obj.type === 'arrow') {
                         // For line, use original click coords, as line points are not rotated with the bbox.
                        if (isPointNearLine(coordsPage.x, coordsPage.y,
                            obj.points[0].x, obj.points[0].y, obj.points[1].x, obj.points[1].y,
                            Math.max(5 / currentCanvasScale, (obj.strokeWidth || 1) * 1.5) // Tolerance in page points
                        )) return obj;
                    } else if (obj.type === 'circle') {
                        const cCenterX = obj.x + obj.width/2;
                        const cCenterY = obj.y + obj.height/2;
                        const cRadius = Math.min(obj.width, obj.height)/2;
                        const dist = Math.sqrt(Math.pow(localClickX - cCenterX, 2) + Math.pow(localClickY - cCenterY, 2));
                        if (dist <= cRadius + ((obj.strokeWidth || 0) / currentCanvasScale * 2) ) return obj; // Add some tolerance
                    } else if (obj.type === 'freehand' || (obj.type === 'signature' && obj.points)) {
                        const tolerance = Math.max(5 / currentCanvasScale, (obj.strokeWidth || 1) * 1.5);
                        for (let j = 0; j < obj.points.length - 1; j++) {
                            if (isPointNearLine(coordsPage.x, coordsPage.y,
                                obj.points[j].x, obj.points[j].y,
                                obj.points[j+1].x, obj.points[j+1].y, tolerance
                            )) return obj;
                        }
                    } else { // Rect, Text, Image, Stamp, Highlight - BBox is enough
                        return obj;
                    }
                }
            }
            return null;
        }

        function isPointNearLine(px, py, x1, y1, x2, y2, tolerance) { /* ... (unchanged) ... */
            const L2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
            if (L2 === 0) return Math.sqrt((px-x1)*(px-x1) + (py-y1)*(py-y1)) < tolerance;
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
            t = Math.max(0, Math.min(1, t));
            const nearX = x1 + t * (x2 - x1);
            const nearY = y1 + t * (y2 - y1);
            const dist = Math.sqrt((px-nearX)*(px-nearX) + (py-nearY)*(py-nearY));
            return dist < tolerance;
        }


        async function handleImageUpload(e) { /* ... (similar, ensure coords and dimensions are in PDF page points) ... */
            const imageFile = e.target.files[0];
            if (!imageFile || !pdfJsDoc || currentPageNum < 1) return;
            saveStateForUndo(true);

            const imageBytes = await imageFile.arrayBuffer();
            const tempImg = new Image();
            const objectURL = URL.createObjectURL(imageFile);

            tempImg.onload = () => {
                URL.revokeObjectURL(objectURL);
                const aspectRatio = tempImg.width / tempImg.height;
                let imgWidthPagePt = 150; // Default width in PDF points
                let imgHeightPagePt = imgWidthPagePt / aspectRatio;

                // Center on current view (approx)
                const currentViewport = currentPdfJsPage.getViewport({ scale: currentCanvasScale });
                const centerXPagePt = (currentViewport.width / currentCanvasScale / 2) - (imgWidthPagePt / 2);
                const centerYPagePt = (currentViewport.height / currentCanvasScale / 2) - (imgHeightPagePt / 2);

                const newImageObject = {
                    id: generateId(), type: 'image',
                    x: Math.max(0, centerXPagePt), y: Math.max(0, centerYPagePt),
                    width: imgWidthPagePt, height: imgHeightPagePt,
                    originalWidth: tempImg.width, originalHeight: tempImg.height, // For aspect ratio on resize
                    imageBytes: imageBytes, imageType: imageFile.type,
                    imageElement: tempImg, // For canvas drawing
                    opacity: 1, layerId: currentLayerId, visible: true
                };
                editsPerPage[currentPageNum - 1].push(newImageObject);
                selectedObject = newImageObject;
                renderAnnotations();
                updateUIState();
            };
            tempImg.onerror = () => { URL.revokeObjectURL(objectURL); alert("خطأ في تحميل الصورة."); };
            tempImg.src = objectURL;
            e.target.value = null;
        }

        async function handleSignatureUpload(e) { /* ... (similar to image upload, but for type 'signature') ... */
            const imageFile = e.target.files[0];
            if (!imageFile || !pdfJsDoc || currentPageNum < 1) return;
            saveStateForUndo(true);
            const imageBytes = await imageFile.arrayBuffer();
            const tempImg = new Image();
            const objectURL = URL.createObjectURL(imageFile);
            tempImg.onload = () => {
                URL.revokeObjectURL(objectURL);
                const aspectRatio = tempImg.width / tempImg.height;
                let sigWidthPagePt = 120; // Default width in PDF points
                let sigHeightPagePt = sigWidthPagePt / aspectRatio;
                const currentViewport = currentPdfJsPage.getViewport({ scale: currentCanvasScale });
                const centerXPagePt = (currentViewport.width / currentCanvasScale / 2) - (sigWidthPagePt / 2);
                const centerYPagePt = (currentViewport.height / currentCanvasScale / 2) - (sigHeightPagePt / 2);

                const newSigObject = {
                    id: generateId(), type: 'signature', // Mark as image signature
                    x: Math.max(0, centerXPagePt), y: Math.max(0, centerYPagePt),
                    width: sigWidthPagePt, height: sigHeightPagePt,
                    originalWidth: tempImg.width, originalHeight: tempImg.height,
                    imageBytes: imageBytes, imageType: imageFile.type,
                    imageElement: tempImg, points: null, // No path points for image signature
                    opacity: 1, layerId: currentLayerId, visible: true
                };
                editsPerPage[currentPageNum - 1].push(newSigObject);
                selectedObject = newSigObject;
                renderAnnotations();
                updateUIState();
            };
            tempImg.onerror = () => { URL.revokeObjectURL(objectURL); alert("خطأ في تحميل صورة التوقيع."); };
            tempImg.src = objectURL;
            e.target.value = null;
        }


        async function savePdfAnnotations(asCopy = false) {
            if (!originalPdfFile || isProcessing) return;
            isProcessing = true;
            statusDiv.innerHTML = 'جاري تطبيق التعديلات وحفظ الملف... <div class="spinner"></div>';
            updateUIState();

            try {
                let workingPdfLibDoc;
                if (asCopy) {
                    workingPdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer, { fontkit: window.fontkit, updateMetadata: false });
                } else {
                    if (!pdfLibDoc) { // Load if not already loaded (e.g. if deferred)
                         pdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer, { fontkit: window.fontkit, updateMetadata: false });
                    }
                    workingPdfLibDoc = pdfLibDoc;
                }
                 // It's good practice to register fontkit for each document instance
                workingPdfLibDoc.registerFontkit(window.fontkit);


                // Ensure fonts are embedded in workingPdfLibDoc
                const localEmbeddedFontsForSave = {};
                const fontsInUse = new Set();
                editsPerPage.flat().filter(obj => obj && obj.type === 'text' && obj.fontName).forEach(obj => fontsInUse.add(obj.fontName));

                for (const fontName of fontsInUse) {
                    if (StandardFonts[fontName]) {
                        localEmbeddedFontsForSave[fontName] = await workingPdfLibDoc.embedFont(StandardFonts[fontName]);
                    } else if (fontName === 'Cairo') {
                        try {
                            const cairoFontBytes = await fetch(DEFAULT_FONT_PATH).then(res => res.arrayBuffer());
                            localEmbeddedFontsForSave['Cairo'] = await workingPdfLibDoc.embedFont(cairoFontBytes, { subset: true });
                        } catch (err) {
                            console.warn(`تعذر تضمين خط Cairo للحفظ، سيتم استخدام Helvetica: ${err}`);
                            localEmbeddedFontsForSave[fontName] = await workingPdfLibDoc.embedFont(StandardFonts.Helvetica);
                        }
                    } else { // Fallback for other custom fonts
                        console.warn(`خط غير معروف ${fontName}، سيتم استخدام Helvetica.`);
                        localEmbeddedFontsForSave[fontName] = await workingPdfLibDoc.embedFont(StandardFonts.Helvetica);
                    }
                }
                if (!localEmbeddedFontsForSave['Helvetica']) { // Ensure Helvetica
                    localEmbeddedFontsForSave['Helvetica'] = await workingPdfLibDoc.embedFont(StandardFonts.Helvetica);
                }


                for (let i = 0; i < workingPdfLibDoc.getPageCount(); i++) {
                    if (!editsPerPage[i] || editsPerPage[i].length === 0) continue;

                    const page = workingPdfLibDoc.getPage(i);
                    const { width: naturalPageWidth, height: naturalPageHeight } = page.getSize();
                    // PDF page rotation is handled by pdf-lib; annotations are applied to natural orientation.

                    const sortedEdits = [...editsPerPage[i]].sort((a, b) => {
                        const layerA = layers.find(l => l.id === a.layerId) || { order: 0 };
                        const layerB = layers.find(l => l.id === b.layerId) || { order: 0 };
                        if (layerA.order !== layerB.order) return layerA.order - layerB.order;
                        return editsPerPage[i].indexOf(a) - editsPerPage[i].indexOf(b); // Fallback to creation order
                    });

                    for (const obj of sortedEdits) {
                        if (!obj || !obj.visible) continue;

                        // Object coords (obj.x, obj.y) are top-left in PDF points.
                        // pdf-lib y is bottom-left.
                        // Object rotation is obj.rotation in radians.
                        const baseDrawOptions = {
                            opacity: obj.opacity === undefined ? 1 : obj.opacity,
                            rotate: degrees(obj.rotation || 0)
                        };

                        switch (obj.type) {
                            case 'text':
                                let pdfTextAlign = TextAlignment.Right; // Default for Arabic context in pdf-lib
                                if (obj.align === 'center') pdfTextAlign = TextAlignment.Center;
                                else if (obj.align === 'left') pdfTextAlign = TextAlignment.Left;

                                page.drawText(obj.content, {
                                    ...baseDrawOptions,
                                    x: obj.x, // obj.x is the PDF point x for the alignment type
                                    y: naturalPageHeight - obj.y - obj.fontSize, // Baseline from top
                                    size: obj.fontSize,
                                    font: localEmbeddedFontsForSave[obj.fontName] || localEmbeddedFontsForSave['Helvetica'],
                                    color: hexToRgb(obj.colorHex),
                                    lineHeight: obj.fontSize * 1.2,
                                    maxWidth: obj.width, // Max width for wrapping
                                    alignment: pdfTextAlign,
                                    // wordBreaks: [' '] // pdf-lib handles basic breaking
                                });
                                break;
                            case 'highlight':
                                page.drawRectangle({
                                    ...baseDrawOptions,
                                    x: obj.x, y: naturalPageHeight - obj.y - obj.height,
                                    width: obj.width, height: obj.height,
                                    color: hexToRgb(obj.colorHex),
                                    borderWidth: 0
                                });
                                break;
                            case 'rect':
                                page.drawRectangle({
                                    ...baseDrawOptions,
                                    x: obj.x, y: naturalPageHeight - obj.y - obj.height,
                                    width: obj.width, height: obj.height,
                                    color: (obj.fillColorHex && obj.fillColorHex !== 'transparent') ? hexToRgb(obj.fillColorHex) : undefined,
                                    borderColor: (obj.strokeColorHex && obj.strokeWidth > 0) ? hexToRgb(obj.strokeColorHex) : undefined,
                                    borderWidth: (obj.strokeWidth > 0) ? obj.strokeWidth : undefined,
                                    // borderLineCap, borderLineJoin, borderDashArray can be added for advanced styling
                                });
                                break;
                            case 'circle':
                                page.drawCircle({
                                    ...baseDrawOptions,
                                    x: obj.x + obj.width/2, // Center X
                                    y: naturalPageHeight - (obj.y + obj.height/2), // Center Y
                                    size: Math.min(obj.width, obj.height)/2, // Radius
                                    color: (obj.fillColorHex && obj.fillColorHex !== 'transparent') ? hexToRgb(obj.fillColorHex) : undefined,
                                    borderColor: (obj.strokeColorHex && obj.strokeWidth > 0) ? hexToRgb(obj.strokeColorHex) : undefined,
                                    borderWidth: (obj.strokeWidth > 0) ? obj.strokeWidth : undefined,
                                });
                                break;
                            case 'line':
                                if (!obj.points || obj.points.length < 2) continue;
                                page.drawLine({
                                    // No ...baseDrawOptions for line, as it has start/end and thickness
                                    start: { x: obj.points[0].x, y: naturalPageHeight - obj.points[0].y },
                                    end: { x: obj.points[1].x, y: naturalPageHeight - obj.points[1].y },
                                    thickness: obj.strokeWidth,
                                    color: hexToRgb(obj.strokeColorHex),
                                    opacity: obj.opacity === undefined ? 1 : obj.opacity,
                                    // lineCap, dashArray for styles
                                });
                                if (obj.isArrow) {
                                    const ax1 = obj.points[0].x, ay1_pdf = naturalPageHeight - obj.points[0].y;
                                    const ax2 = obj.points[1].x, ay2_pdf = naturalPageHeight - obj.points[1].y;
                                    const arrowAngle = Math.atan2(ay2_pdf - ay1_pdf, ax2 - ax1);
                                    const arrowSize = Math.max(5, obj.strokeWidth * 3); // Arrow size in PDF points

                                    const path = `M ${ax2 - arrowSize * Math.cos(arrowAngle - Math.PI / 7)} ${ay2_pdf - arrowSize * Math.sin(arrowAngle - Math.PI / 7)} ` +
                                                 `L ${ax2} ${ay2_pdf} ` +
                                                 `L ${ax2 - arrowSize * Math.cos(arrowAngle + Math.PI / 7)} ${ay2_pdf - arrowSize * Math.sin(arrowAngle + Math.PI / 7)}`;
                                    page.drawSvgPath(path, { // Open arrowhead
                                        borderColor: hexToRgb(obj.strokeColorHex),
                                        borderWidth: obj.strokeWidth,
                                        opacity: obj.opacity === undefined ? 1 : obj.opacity,
                                    });
                                }
                                break;
                            case 'freehand':
                            case 'signature': // Path-based
                                if (obj.points && obj.points.length > 1) {
                                    let svgPath = `M ${obj.points[0].x} ${naturalPageHeight - obj.points[0].y}`;
                                    for (let k = 1; k < obj.points.length; k++) {
                                        svgPath += ` L ${obj.points[k].x} ${naturalPageHeight - obj.points[k].y}`;
                                    }
                                    page.drawSvgPath(svgPath, {
                                        borderColor: hexToRgb(obj.colorHex),
                                        borderWidth: obj.strokeWidth, // Assuming strokeWidth is in PDF points
                                        opacity: obj.opacity === undefined ? 1 : obj.opacity,
                                        // SVG paths don't take rotate option directly here. Points should be pre-rotated if needed.
                                        // For simplicity, freehand/signature usually not rotated by handle.
                                        // lineCap: LineCapStyle.Round, lineJoin: LineJoinStyle.Round, (pdf-lib enums)
                                    });
                                } else if (obj.type === 'signature' && obj.imageBytes) { // Image-based signature
                                    let embeddedImage;
                                    if (obj.imageType === 'image/png') embeddedImage = await workingPdfLibDoc.embedPng(obj.imageBytes);
                                    else if (obj.imageType === 'image/jpeg') embeddedImage = await workingPdfLibDoc.embedJpg(obj.imageBytes);
                                    if (embeddedImage) {
                                        page.drawImage(embeddedImage, {
                                            ...baseDrawOptions,
                                            x: obj.x, y: naturalPageHeight - obj.y - obj.height,
                                            width: obj.width, height: obj.height
                                        });
                                    }
                                }
                                break;
                            case 'stamp':
                                const stampColorRgb = hexToRgb(obj.colorHex);
                                const stampFillRgb = hexToRgb(obj.colorHex.substring(0,7) + '33'); // ~20% alpha
                                if (obj.stampShape === 'circle') {
                                    page.drawCircle({
                                        ...baseDrawOptions,
                                        x: obj.x + obj.width/2, y: naturalPageHeight - (obj.y + obj.height/2),
                                        size: Math.min(obj.width, obj.height)/2,
                                        color: stampFillRgb, borderColor: stampColorRgb, borderWidth: 2,
                                    });
                                } else {
                                    page.drawRectangle({
                                        ...baseDrawOptions,
                                        x: obj.x, y: naturalPageHeight - obj.y - obj.height,
                                        width: obj.width, height: obj.height,
                                        color: stampFillRgb, borderColor: stampColorRgb, borderWidth: 2,
                                    });
                                }
                                const stampFontSize = Math.min(obj.width, obj.height)/3;
                                page.drawText(obj.text, {
                                    ...baseDrawOptions, // Object rotation handled
                                    x: obj.x + obj.width/2, // Center X
                                    y: naturalPageHeight - (obj.y + obj.height/2) - stampFontSize/2.5, // Baseline for centered
                                    size: stampFontSize,
                                    font: localEmbeddedFontsForSave['Helvetica'],
                                    color: stampColorRgb,
                                    alignment: TextAlignment.Center,
                                    maxWidth: obj.width * 0.9,
                                });
                                break;
                            case 'image':
                                if (obj.imageBytes) {
                                    let embeddedImage;
                                    if (obj.imageType === 'image/png') embeddedImage = await workingPdfLibDoc.embedPng(obj.imageBytes);
                                    else if (obj.imageType === 'image/jpeg') embeddedImage = await workingPdfLibDoc.embedJpg(obj.imageBytes);
                                    if (embeddedImage) {
                                        page.drawImage(embeddedImage, {
                                            ...baseDrawOptions,
                                            x: obj.x, y: naturalPageHeight - obj.y - obj.height,
                                            width: obj.width, height: obj.height
                                        });
                                    }
                                }
                                break;
                        }
                    }
                }

                const pdfBytesOutput = await workingPdfLibDoc.save({ useObjectStreams: true });
                const blob = new Blob([pdfBytesOutput], { type: 'application/pdf' });
                let filename = outputBaseFilenameInput.value.trim() || (originalPdfFile ? originalPdfFile.name.replace(/\.pdf$/i, '_مُعدل.pdf') : 'مستند_مُعدل.pdf');
                if (!filename.toLowerCase().endsWith('.pdf')) filename += '.pdf';
                if (asCopy) filename = filename.replace(/\.pdf$/i, `_نسخة_${Date.now()}.pdf`);

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

                statusDiv.textContent = 'تم حفظ الملف بنجاح!';
                statusDiv.style.color = 'var(--success-color)';

                if (!asCopy) { // If saved over, update the main buffer for pdfLibDoc
                    pdfLibDocArrayBuffer = pdfBytesOutput.slice(0);
                    pdfLibDoc = workingPdfLibDoc; // The main doc instance is now the saved one
                }

            } catch (err) {
                console.error("Error saving PDF:", err);
                statusDiv.textContent = `خطأ أثناء حفظ الملف: ${err.message}`;
                statusDiv.style.color = 'var(--danger-color)';
            } finally {
                isProcessing = false;
                updateUIState();
            }
        }

        async function printCurrentPdf() {
            if (!pdfJsDoc || isProcessing) return;
            // Best approach is to use the Blob from savePdfAnnotations logic to print
            // This ensures printed version has annotations.
            try {
                // Temporarily save to a blob (without downloading)
                 if (!pdfLibDoc) pdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer, { fontkit: window.fontkit, updateMetadata: false });

                // Apply edits as in savePdfAnnotations to a temporary document
                const tempDocToPrint = await PDFDocument.load(pdfLibDocArrayBuffer, { fontkit: window.fontkit, updateMetadata: false });
                tempDocToPrint.registerFontkit(window.fontkit);
                // ... (Apply edits to tempDocToPrint - this is a duplication of save logic, ideally refactor)
                // For brevity, assuming edits are applied similar to savePdfAnnotations...
                 for (let i = 0; i < tempDocToPrint.getPageCount(); i++) {
                    if (!editsPerPage[i] || editsPerPage[i].length === 0) continue;
                    const page = tempDocToPrint.getPage(i);
                    const { height: naturalPageHeight } = page.getSize();
                    for (const obj of editsPerPage[i]) {
                         if (!obj || !obj.visible) continue;
                         // Simplified application of objects for print example
                         if (obj.type === 'text') {
                            page.drawText(obj.content, { x:obj.x, y: naturalPageHeight - obj.y - obj.fontSize, size: obj.fontSize, font: await tempDocToPrint.embedFont(StandardFonts.Helvetica) });
                         }
                         // ... add other object types ...
                    }
                }


                const pdfBytesForPrint = await tempDocToPrint.save();
                const blob = new Blob([pdfBytesForPrint], { type: 'application/pdf' });
                const objectUrl = URL.createObjectURL(blob);

                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = objectUrl;
                document.body.appendChild(iframe);
                iframe.onload = () => {
                    iframe.contentWindow.print();
                    setTimeout(() => {
                        document.body.removeChild(iframe);
                        URL.revokeObjectURL(objectUrl);
                    }, 1000); // Delay removal to ensure print dialog appears
                };
            } catch (err) {
                console.error("Error preparing for print:", err);
                alert("حدث خطأ أثناء تجهيز الملف للطباعة.");
            }
        }


        function showHelp() { /* ... (unchanged, assumed good) ... */ }

        function updateUIState() {
            const fileLoaded = !!pdfJsDoc;
            saveBtn.disabled = !fileLoaded || isProcessing;
            saveCopyBtn.disabled = !fileLoaded || isProcessing;
            printBtn.disabled = !fileLoaded || isProcessing;
            deleteBtn.disabled = !selectedObject || isProcessing || !fileLoaded;
            const currentPageHasEdits = fileLoaded && editsPerPage[currentPageNum - 1] && editsPerPage[currentPageNum - 1].length > 0;
            clearPageBtn.disabled = !fileLoaded || isProcessing || !currentPageHasEdits;

            toolbarButtons.forEach(btn => btn.disabled = !fileLoaded || isProcessing);
            layersToolBtn.disabled = !fileLoaded || isProcessing; // Layers depend on loaded PDF

            if (fileLoaded) {
                fileInfoDisplay.textContent = `الملف: ${originalPdfFile.name} | ${pdfJsDoc.numPages} صفحات (للعرض) | الحجم: ${formatBytes(originalPdfFile.size)}`;
                if (!outputBaseFilenameInput.value && originalPdfFile) {
                    outputBaseFilenameInput.value = originalPdfFile.name.replace(/\.pdf$/i, '');
                }
                // Page indicator for pdfJsDoc (view)
                pageIndicator.textContent = `صفحة ${currentPageNum} / ${pdfJsDoc.numPages}`;
                prevPageBtn.disabled = currentPageNum <= 1 || isProcessing;
                nextPageBtn.disabled = currentPageNum >= pdfJsDoc.numPages || isProcessing;
                // Add/Delete page buttons might refer to pdfLibDoc which can differ.
                // For simplicity, enable if file loaded. Actual logic will use pdfLibDoc.
                addPageBtn.disabled = isProcessing || !originalPdfFile; // Need original to add to
                deletePageBtn.disabled = isProcessing || !originalPdfFile || (pdfLibDoc ? pdfLibDoc.getPageCount() <=1 : pdfJsDoc.numPages <=1) ;


            } else {
                fileInfoDisplay.textContent = 'لم يتم اختيار ملف.';
                outputBaseFilenameInput.value = '';
                pageIndicator.textContent = 'صفحة - / -';
                prevPageBtn.disabled = true; nextPageBtn.disabled = true;
                addPageBtn.disabled = true; deletePageBtn.disabled = true;
                editorArea.style.display = 'none';
            }
            updateHistoryButtons();
            updateAnnotationCanvasCursor();
            cmPasteBtn.disabled = !copiedObject;
        }

        // --- Drag and Drop for PDF file ---
        document.body.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); document.body.style.opacity = '0.7';});
        document.body.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); document.body.style.opacity = '1';});
        document.body.addEventListener('drop', (e) => {
            e.preventDefault(); e.stopPropagation(); document.body.style.opacity = '1';
            if (isProcessing) return;
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                pdfInput.files = files;
                pdfInput.dispatchEvent(new Event('change', { bubbles: true }));
            } else if (files.length > 0) {
                alert("يرجى إفلات ملف PDF صالح.");
            }
        });

        window.addEventListener('resize', () => {
            if (pdfJsDoc && editorArea.style.display === 'block') {
                renderPdfPage(currentPageNum, true); // Re-render with scale to fit
            }
        });

        initializeEditor();
    </script>
</body>
</html>
