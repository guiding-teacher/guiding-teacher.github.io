<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>محرر PDF المحترف</title>
    <!-- pdf-lib and fontkit -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js"></script>
    <!-- pdf.js for rendering PDF content -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";</script>
    <!-- Signature Pad -->
    <script src="https://unpkg.com/signature_pad@4.1.5/dist/signature_pad.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #4a6bff; --secondary-color: #00c9a7; --background-start: #121212;
            --background-end: #1e1e1e; --text-color: #f5f5f5; --container-bg: #2d2d2d;
            --container-shadow: rgba(0, 0, 0, 0.5); --input-bg: #424242; --input-border: #616161;
            --input-text: #ffffff; --success-color: #28a745; --danger-color: #dc3545;
            --warning-color: #ffc107; --info-color: #17a2b8; --border-radius: 10px;
            --box-shadow: 0 12px 30px var(--container-shadow); --button-text-color: #ffffff;
            --canvas-border: #616161; --toolbar-bg: #3a3a3a; --footer-bg: #222; --footer-text: #aaa;
            --selected-color: var(--primary-color); --highlight-color: rgba(255, 255, 0, 0.3);
            --text-highlight-color: #ffff00; --stamp-color: #ff4081;
        }
        html { box-sizing: border-box; font-size: 16px; }
        *, *:before, *:after { box-sizing: inherit; }
        body {
            font-family: 'Cairo', sans-serif; display: flex; flex-direction: column; justify-content: space-between;
            align-items: center; min-height: 100vh; margin: 0; padding: 10px;
            background: linear-gradient(135deg, var(--background-start), var(--background-end));
            color: var(--text-color); direction: rtl; line-height: 1.6; user-select: none;
        }
        .editor-container {
            background-color: var(--container-bg); padding: 20px; border-radius: var(--border-radius);
            box-shadow: var(--box-shadow); text-align: center; max-width: 95%; width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 20px;
        }
        h1 {
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text; background-clip: text; color: transparent;
            margin-bottom: 20px; font-weight: 700; font-size: 1.6rem;
        }
        #pdfInput { display: none; }
        .file-label {
            display: inline-block; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--button-text-color); padding: 10px 20px; border-radius: 8px; cursor: pointer;
            font-size: 0.9rem; transition: all .3s ease; margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3); border: none;
        }
        .file-label:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0, 123, 255, 0.4); }
        #fileInfoDisplay { margin-top: 5px; margin-bottom: 15px; font-size: 0.85em; color: #bdc3c7; min-height: 1em;}
        #editorArea { display: none; margin-top: 15px; }
        #mainControls { display: flex; justify-content: space-between; align-items: center; margin-bottom:10px; flex-wrap: wrap; gap: 10px;}
        #toolbar {
            background-color: var(--toolbar-bg); padding: 8px; border-radius: var(--border-radius);
            display: flex; justify-content: center; align-items: center; gap: 8px; flex-wrap: wrap;
            border: 1px solid var(--input-border);
        }
        .tool-button, .action-button, .mode-button {
            background-color: var(--primary-color); color: white; border: none; padding: 8px 10px;
            border-radius: 5px; cursor: pointer; transition: all 0.3s; font-family: 'Cairo', sans-serif;
            font-size: 0.85rem; line-height: 1; display: flex; align-items: center; gap: 5px;
        }
        .tool-button i, .action-button i, .mode-button i { margin-left: 5px; }
        .tool-button:hover, .tool-button.active, .action-button:hover, .mode-button:hover {
            background-color: var(--secondary-color); transform: translateY(-1px);
        }
        .tool-button.active {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            background-color: var(--secondary-color);
        }
        .action-button:disabled, .tool-button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.7;}
        .action-button.danger { background-color: var(--danger-color); }
        .action-button.danger:hover { background-color: #c82333; }
        .action-button.success { background-color: var(--success-color); }
        .action-button.success:hover { background-color: #218838; }
        .action-button.info { background-color: var(--info-color); }
        .action-button.info:hover { background-color: #138496; }

        #toolOptions {
            padding: 8px; background-color: var(--input-bg); margin-bottom: 10px; border-radius:8px;
            display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap; font-size: 0.8rem;
        }
        #toolOptions label, #toolOptions input, #toolOptions select { color: var(--text-color); }
        #toolOptions input[type="color"] { padding: 0; height: 25px; width: 25px; border-radius: 5px; vertical-align: middle; cursor: pointer;}
        #toolOptions input[type="text"], #toolOptions input[type="number"], #toolOptions select {
            padding: 4px; background-color: var(--container-bg); border: 1px solid var(--input-border);
            border-radius: 5px; font-size: 0.8rem; min-width: 60px;
        }
        #toolOptions input[type="range"] { width: 80px; }
        #pageNavigation {
            display: flex; justify-content: space-between; align-items: center; padding: 8px;
            background-color: var(--toolbar-bg); border-radius:8px; margin-bottom: 10px;
        }
        #pageNavigation button { font-size: 0.85rem; }
        #pageIndicator { font-weight: bold; font-size: 0.9em; }
        #canvasContainer {
            width: 100%; max-width: 800px; margin: 10px auto; border: 2px solid var(--canvas-border);
            background-color: #808080;
            position: relative; overflow: auto; max-height: 65vh;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #pdfRenderCanvas { display: block; }
        #annotationCanvas { position: absolute; top: 0; left: 0; cursor: crosshair; }
        #signaturePadContainer {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--container-bg); border: 2px solid var(--primary-color);
            border-radius: var(--border-radius); padding: 15px; z-index: 1001;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: none; flex-direction: column; align-items: center;
        }
        #signaturePadCanvas { background-color: #fff; border-radius: 5px; cursor: crosshair; }
        #signaturePadActions { margin-top: 10px; display: flex; gap: 10px; }


        #annotationCanvas.text-tool-cursor { cursor: text; }
        #annotationCanvas.move-tool-cursor { cursor: grab; }
        #annotationCanvas.moving-tool-cursor { cursor: grabbing; }

        #outputBaseFilename {
            display: block; width: calc(100% - 30px); padding: 8px 12px; margin: 15px auto;
            border: 1px solid var(--input-border); border-radius: 8px; font-size: 0.9rem;
            background-color: var(--input-bg); color: var(--input-text); transition: border 0.3s;
        }
        #outputBaseFilename:focus { border-color: var(--primary-color); outline: none; }
        #saveBtn { font-size: 1rem; padding: 12px 30px; margin-top: 10px; }
        #statusDiv { margin-top: 5px; font-weight: 700; min-height: 1.3em; font-size: 0.9rem;}
        .spinner {
            display: inline-block; border: 3px solid rgba(255, 255, 255, 0.2);
            width: 16px; height: 16px; border-radius: 50%; border-left-color: var(--primary-color);
            animation: spin 1s linear infinite; margin-left: 8px; vertical-align: middle;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        footer { font-size: 0.8em; margin-top: 20px; text-align: center; color: var(--footer-text); }
        footer a { color: var(--secondary-color); text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        .context-menu {
            position: absolute; background-color: var(--container-bg); border: 1px solid var(--input-border);
            border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 1000;
            display: none; flex-direction: column; min-width: 150px;
        }
        .context-menu button {
            background: none; border: none; color: var(--text-color); padding: 8px 12px;
            text-align: right; cursor: pointer; font-family: 'Cairo', sans-serif;
            transition: background-color 0.2s;
        }
        .context-menu button:hover { background-color: var(--primary-color); }
        .context-menu button i { margin-left: 8px; }
        .context-menu .separator { height: 1px; background-color: var(--input-border); margin: 4px 0; }

        #zoomControls {
            position: absolute; top: 10px; left: 10px; background-color: var(--toolbar-bg);
            border-radius: 5px; padding: 5px; display: flex; flex-direction: column; gap: 5px;
            z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #zoomControls button {
            background-color: var(--primary-color); color: white; border: none;
            width: 30px; height: 30px; border-radius: 3px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        #zoomControls button:hover { background-color: var(--secondary-color); }
        #zoomLevel { text-align: center; font-size: 0.8em; color: var(--text-color); }

        [data-tooltip] { position: relative; }
        [data-tooltip]:hover::after {
            content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%;
            transform: translateX(-50%); background-color: #333; color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 0.8em; white-space: nowrap;
            z-index: 10000; margin-bottom: 5px;
        }

        @media (min-width: 768px) {
            body { padding: 20px; }
            .editor-container { padding: 25px; max-width: 90%;}
            h1 { font-size: 2rem; margin-bottom: 25px; }
            #toolbar { padding: 10px; gap: 10px; }
            #canvasContainer { margin: 15px auto; max-height: 70vh; }
            #saveBtn { font-size: 1.1rem; padding: 14px 35px; }
        }
        @media (max-width: 600px) {
            #mainControls { flex-direction: column; }
        }
    </style>
</head>
<body>
    <button onclick="window.location.href='index.html'" 
      style="all: unset; position: fixed; top: 21px; left: 20px; font-size: 30px; color: #b7b63c; text-shadow: 1px 1px 1px #52484a; cursor: pointer; z-index: 9999;">
      <i class="fas fa-home"></i> 
    </button>
    <div class="editor-container">
        <h1>محرر PDF المحترف</h1>
        <label for="pdfInput" class="file-label" data-tooltip="اختر ملف PDF لتحريره">
            <i class="fas fa-file-pdf"></i> اختر ملف PDF
        </label>
        <input type="file" id="pdfInput" accept="application/pdf">
        <span id="fileInfoDisplay">لم يتم اختيار ملف.</span>

        <div id="editorArea">
            <div id="mainControls">
                <div id="toolbar">
                    <button class="tool-button" id="selectTool" data-tooltip="تحديد (V)"><i class="fas fa-mouse-pointer"></i></button>
                    <button class="tool-button" id="textTool" data-tooltip="نص (T)"><i class="fas fa-font"></i></button>
                    <button class="tool-button" id="highlightTool" data-tooltip="تظليل"><i class="fas fa-highlighter"></i></button>
                    <button class="tool-button" id="rectTool" data-tooltip="مستطيل (R)"><i class="fas fa-vector-square"></i></button>
                    <button class="tool-button" id="circleTool" data-tooltip="دائرة"><i class="far fa-circle"></i></button>
                    <button class="tool-button" id="lineTool" data-tooltip="خط (L)"><i class="fas fa-minus"></i></button>
                    <button class="tool-button" id="arrowTool" data-tooltip="سهم"><i class="fas fa-arrow-right"></i></button>
                    <button class="tool-button" id="freehandTool" data-tooltip="رسم حر (P)"><i class="fas fa-pencil-alt"></i></button>
                    <button class="tool-button" id="signatureTool" data-tooltip="توقيع"><i class="fas fa-signature"></i></button>
                    <button class="tool-button" id="stampTool" data-tooltip="ختم"><i class="fas fa-stamp"></i></button>
                    <button class="tool-button" id="imageTool" data-tooltip="صورة (I)"><i class="fas fa-image"></i></button>
                    <input type="file" id="imageUpload" accept="image/png, image/jpeg" style="display:none;">
                    <input type="file" id="signatureUpload" accept="image/png, image/jpeg" style="display:none;">
                    <button class="tool-button" id="eraserTool" data-tooltip="ممحاة (E)"><i class="fas fa-eraser"></i></button>
                </div>
                <div id="actionsBar">
                    <button class="action-button" id="undoBtn" data-tooltip="تراجع (Ctrl+Z)"><i class="fas fa-undo"></i></button>
                    <button class="action-button" id="redoBtn" data-tooltip="إعادة (Ctrl+Y)"><i class="fas fa-redo"></i></button>
                    <button class="action-button danger" id="deleteBtn" data-tooltip="حذف العنصر المحدد (Del)"><i class="fas fa-trash-alt"></i></button>
                    <button class="action-button info" id="clearPageBtn" data-tooltip="مسح تعديلات الصفحة"><i class="fas fa-broom"></i></button>
                </div>
            </div>

            <div id="toolOptions">
                <div id="textOptionsContainer" class="options-panel" style="display:none;">
                    <label for="textColor">لون:</label> <input type="color" id="textColor" value="#000000">
                    <label for="fontSize">حجم:</label> <input type="number" id="fontSize" value="12" min="1" max="100">
                    <label for="fontSelector">خط:</label>
                    <select id="fontSelector">
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times-Roman">Times New Roman</option>
                        <option value="Courier">Courier</option>
                        <option value="Cairo">Cairo</option>
                    </select>
                    <label for="textAlign">محاذاة:</label>
                    <select id="textAlign">
                        <option value="right">يمين</option>
                        <option value="center">وسط</option>
                        <option value="left">يسار</option>
                    </select>
                </div>
                <div id="highlightOptionsContainer" class="options-panel" style="display:none;">
                    <label for="highlightColor">لون:</label> <input type="color" id="highlightColor" value="#FFFF00">
                    <label for="highlightOpacity">شفافية:</label> <input type="range" id="highlightOpacity" min="0.1" max="1" step="0.05" value="0.3">
                </div>
                <div id="shapeOptionsContainer" class="options-panel" style="display:none;">
                    <label for="fillColor">تعبئة:</label> <input type="color" id="fillColor" value="#FF0000">
                    <label for="strokeColor">حد:</label> <input type="color" id="strokeColor" value="#000000">
                    <label for="strokeWidth">سمك:</label> <input type="number" id="strokeWidth" value="2" min="0" max="20">
                    <label for="shapeOpacity">شفافية:</label> <input type="range" id="shapeOpacity" min="0.05" max="1" step="0.05" value="1">
                </div>
                <div id="freehandOptionsContainer" class="options-panel" style="display:none;">
                    <label for="freehandColor">لون:</label> <input type="color" id="freehandColor" value="#0000FF">
                    <label for="freehandWidth">سمك:</label> <input type="number" id="freehandWidth" value="3" min="1" max="20">
                </div>
                <div id="signatureOptionsContainer" class="options-panel" style="display:none;">
                    <button class="mode-button" id="drawSignatureBtn"><i class="fas fa-pencil-alt"></i> ارسم توقيعك</button>
                    <button class="mode-button" id="uploadSignatureBtn"><i class="fas fa-upload"></i> ارفع صورة توقيع</button>
                </div>
                <div id="stampOptionsContainer" class="options-panel" style="display:none;">
                    <label for="stampType">نوع:</label>
                    <select id="stampType">
                        <option value="approved">موافق</option>
                        <option value="rejected">مرفوض</option>
                        <option value="confidential">سري</option>
                        <option value="draft">مسودة</option>
                        <option value="custom">مخصص</option>
                    </select>
                    <label for="stampColor">لون:</label> <input type="color" id="stampColor" value="#FF4081">
                    <label for="stampText" style="display:none;">نص:</label> <input type="text" id="stampText" placeholder="أدخل النص" style="display:none;">
                </div>
            </div>

            <div id="pageNavigation">
                <button id="prevPageBtn" class="action-button" disabled><i class="fas fa-arrow-right"></i> السابق</button>
                <span id="pageIndicator">صفحة - / -</span>
                <button id="nextPageBtn" class="action-button" disabled>التالي <i class="fas fa-arrow-left"></i></button>
                <button id="addPageBtn" class="action-button info" data-tooltip="إضافة صفحة فارغة (ستظهر بعد الحفظ)"><i class="fas fa-plus"></i></button>
                <button id="deletePageBtn" class="action-button danger" data-tooltip="حذف الصفحة الحالية (سيتم الحذف عند الحفظ)"><i class="fas fa-minus"></i></button>
            </div>

            <div id="canvasContainer">
                <div id="zoomControls">
                    <button id="zoomInBtn" data-tooltip="تكبير (Ctrl++)"><i class="fas fa-search-plus"></i></button>
                    <button id="zoomOutBtn" data-tooltip="تصغير (Ctrl+-)"><i class="fas fa-search-minus"></i></button>
                    <button id="zoomFitBtn" data-tooltip="ملائمة للشاشة"><i class="fas fa-expand"></i></button>
                    <div id="zoomLevel">100%</div>
                </div>
                <canvas id="pdfRenderCanvas"></canvas>
                <canvas id="annotationCanvas"></canvas>
            </div>
            
            <div id="signaturePadContainer">
                <p>ارسم توقيعك في المربع أدناه</p>
                <canvas id="signaturePadCanvas" width="400" height="200"></canvas>
                <div id="signaturePadActions">
                    <button id="confirmSignatureBtn" class="action-button success"><i class="fas fa-check"></i> تأكيد</button>
                    <button id="clearSignatureBtn" class="action-button info"><i class="fas fa-eraser"></i> مسح</button>
                    <button id="cancelSignatureBtn" class="action-button danger"><i class="fas fa-times"></i> إلغاء</button>
                </div>
            </div>
        </div>

        <input type="text" id="outputBaseFilename" placeholder="الاسم الجديد للملف (اختياري)">
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button id="saveBtn" class="action-button success" disabled><i class="fas fa-save"></i> حفظ PDF</button>
            <button id="saveCopyBtn" class="action-button info" disabled><i class="fas fa-copy"></i> حفظ نسخة</button>
            <button id="printBtn" class="action-button" disabled><i class="fas fa-print"></i> طباعة</button>
        </div>
        <div id="statusDiv"></div>
    </div>
    <footer>
        <p>© 2025 جميع الحقوق محفوظة لموقع <a href="index.html">المعلم المرشد</a>.</p>
    </footer>

    <div class="context-menu" id="objectContextMenu">
        <button id="cmBringToFront"><i class="fas fa-arrow-up"></i> إحضار للأمام</button>
        <button id="cmSendToBack"><i class="fas fa-arrow-down"></i> إرسال للخلف</button>
        <div class="separator"></div>
        <button id="cmDelete" class="danger"><i class="fas fa-trash-alt"></i> حذف</button>
    </div>

    <script>
        // --- Library Check ---
        if (typeof window.PDFLib === 'undefined' || typeof window.fontkit === 'undefined' || typeof window.pdfjsLib === 'undefined' || typeof window.SignaturePad === 'undefined') {
            const missing = [
                typeof window.PDFLib === 'undefined' && 'pdf-lib',
                typeof window.fontkit === 'undefined' && 'fontkit',
                typeof window.pdfjsLib === 'undefined' && 'pdf.js',
                typeof window.SignaturePad === 'undefined' && 'SignaturePad'
            ].filter(Boolean);
            const errorMsg = `خطأ فادح: المكتبات التالية غير محملة: ${missing.join(', ')}. لا يمكن تشغيل المحرر.`;
            alert(errorMsg);
            document.body.innerHTML = `<h1 style='color:red; text-align:center; margin-top: 50px;'>${errorMsg}</h1>`;
            throw new Error("Core libraries not loaded.");
        }

        const { PDFDocument, rgb, StandardFonts, degrees, TextAlignment } = window.PDFLib;
        const { getDocument } = window.pdfjsLib;

        // --- DOM Elements ---
        const pdfInput = document.getElementById('pdfInput');
        const editorArea = document.getElementById('editorArea');
        const statusDiv = document.getElementById('statusDiv');
        const toolbarButtons = document.querySelectorAll('#toolbar .tool-button');
        const toolOptionsContainer = document.getElementById('toolOptions');
        const optionsPanels = document.querySelectorAll('.options-panel');
        const imageUploadInput = document.getElementById('imageUpload');
        const signatureUploadInput = document.getElementById('signatureUpload');
        const textColorInput = document.getElementById('textColor');
        const fontSizeInput = document.getElementById('fontSize');
        const fontSelector = document.getElementById('fontSelector');
        const textAlignSelect = document.getElementById('textAlign');
        const highlightColorInput = document.getElementById('highlightColor');
        const highlightOpacityInput = document.getElementById('highlightOpacity');
        const fillColorInput = document.getElementById('fillColor');
        const strokeColorInput = document.getElementById('strokeColor');
        const strokeWidthInput = document.getElementById('strokeWidth');
        const shapeOpacityInput = document.getElementById('shapeOpacity');
        const freehandColorInput = document.getElementById('freehandColor');
        const freehandWidthInput = document.getElementById('freehandWidth');
        const stampTypeSelect = document.getElementById('stampType');
        const stampColorInput = document.getElementById('stampColor');
        const stampTextInput = document.getElementById('stampText');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const addPageBtn = document.getElementById('addPageBtn');
        const deletePageBtn = document.getElementById('deletePageBtn');
        const pageIndicator = document.getElementById('pageIndicator');
        const canvasContainer = document.getElementById('canvasContainer');
        const pdfRenderCanvas = document.getElementById('pdfRenderCanvas');
        const annotationCanvas = document.getElementById('annotationCanvas');
        const renderCtx = pdfRenderCanvas.getContext('2d');
        const annotationCtx = annotationCanvas.getContext('2d', { willReadFrequently: true });
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const objectContextMenu = document.getElementById('objectContextMenu');
        const signaturePadContainer = document.getElementById('signaturePadContainer');
        const signaturePadCanvas = document.getElementById('signaturePadCanvas');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomFitBtn = document.getElementById('zoomFitBtn');
        const zoomLevelDisplay = document.getElementById('zoomLevel');
        let sigPadInstance;


        // --- State ---
        let originalPdfFile = null, pdfJsDoc = null, pdfLibDoc = null;
        let pdfLibDocArrayBuffer = null;
        let totalPages = 0, currentPageNum = 1;
        let currentRenderTask = null;
        let currentCanvasScale = 1.0;
        let activeTool = 'select', isProcessing = false, isDrawing = false;
        let dragStartX, dragStartY, currentDrawingPoints = [];
        let selectedObject = null;
        let editsPerPage = [], undoStack = [], redoStack = [];
        const MIN_OBJECT_SIZE = 5;
        const DEFAULT_FONT_PATH = 'https://fonts.gstatic.com/s/cairo/v28/SLXGc1nY6HkvalIkTpu0xg.woff2';
        const STAMP_TEXTS = { approved: 'موافق', rejected: 'مرفوض', confidential: 'سري', draft: 'مسودة' };

        // --- Utility Functions ---
        const generateId = () => Math.random().toString(36).substr(2, 9);
        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16) / 255, g: parseInt(result[2], 16) / 255, b: parseInt(result[3], 16) / 255 } : { r: 0, g: 0, b: 0 };
        };
        const getPdfPageCoordinates = (event) => {
            const rect = annotationCanvas.getBoundingClientRect();
            return { x: (event.clientX - rect.left) / currentCanvasScale, y: (event.clientY - rect.top) / currentCanvasScale };
        };

        // --- History Management ---
        function saveStateForUndo() {
            redoStack = [];
            undoStack.push(JSON.stringify(editsPerPage));
            if (undoStack.length > 50) undoStack.shift();
            updateHistoryButtons();
        }
        const undo = () => {
            if (undoStack.length === 0) return;
            redoStack.push(JSON.stringify(editsPerPage));
            editsPerPage = JSON.parse(undoStack.pop());
            selectedObject = null;
            renderAnnotations();
            updateHistoryButtons();
        };
        const redo = () => {
            if (redoStack.length === 0) return;
            undoStack.push(JSON.stringify(editsPerPage));
            editsPerPage = JSON.parse(redoStack.pop());
            selectedObject = null;
            renderAnnotations();
            updateHistoryButtons();
        };

        // --- Main Application Logic ---
        async function initializeEditor() {
            pdfInput.addEventListener("change", handleFileSelect);
            setupToolListeners();
            setupCanvasListeners();
            setupActionListeners();
            setupContextMenu();
            setupZoomControls();
            setActiveTool('select');
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file || file.type !== 'application/pdf') return;
            
            originalPdfFile = file;
            isProcessing = true;
            statusDiv.innerHTML = 'جاري تحميل الملف...';
            updateUIState();

            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfLibDocArrayBuffer = arrayBuffer.slice(0);
                pdfJsDoc = await getDocument({ data: arrayBuffer }).promise;
                totalPages = pdfJsDoc.numPages;
                editsPerPage = Array(totalPages).fill(null).map(() => []);
                undoStack = []; redoStack = []; selectedObject = null;
                document.getElementById('fileInfoDisplay').textContent = `الملف: ${file.name} | ${totalPages} صفحات`;
                
                statusDiv.innerHTML = 'تم تحميل الملف بنجاح.';
                editorArea.style.display = 'block';
                currentPageNum = 1;
                await renderPdfPage(currentPageNum, true);
            } catch (err) {
                console.error("Error loading PDF:", err);
                statusDiv.textContent = `خطأ في تحميل الملف: ${err.message}.`;
            } finally {
                isProcessing = false;
                updateUIState();
                e.target.value = null;
            }
        }
        
        async function renderPdfPage(pageNum, scaleToFit = false) {
            // *** FIX APPLIED HERE ***
            // The check for `isProcessing` was removed from the initial guard clause.
            // This allows the initial render call from handleFileSelect to proceed.
            if (!pdfJsDoc) return; 

            isProcessing = true;
            if (currentRenderTask) currentRenderTask.cancel();

            try {
                const page = await pdfJsDoc.getPage(pageNum);
                if (scaleToFit) {
                    const unscaledViewport = page.getViewport({ scale: 1 });
                    currentCanvasScale = (canvasContainer.clientWidth - 4) / unscaledViewport.width;
                }
                const viewport = page.getViewport({ scale: currentCanvasScale });

                pdfRenderCanvas.height = annotationCanvas.height = viewport.height;
                pdfRenderCanvas.width = annotationCanvas.width = viewport.width;

                currentRenderTask = page.render({ canvasContext: renderCtx, viewport });
                await currentRenderTask.promise;
                renderAnnotations();
            } catch (err) {
                if (err.name !== 'RenderingCancelledException') console.error('Error rendering page:', err);
            } finally {
                isProcessing = false;
                updateUIState();
            }
        }

        function renderAnnotations() {
            annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
            const pageEdits = editsPerPage[currentPageNum - 1] || [];
            pageEdits.forEach(obj => drawAnnotationObject(obj));
            if (selectedObject) drawSelectionHandles(selectedObject);
        }

        function drawAnnotationObject(obj) {
            annotationCtx.save();
            annotationCtx.globalAlpha = obj.opacity ?? 1;

            const x = obj.x * currentCanvasScale;
            const y = obj.y * currentCanvasScale;
            const w = obj.width * currentCanvasScale;
            const h = obj.height * currentCanvasScale;
            
            switch (obj.type) {
                case 'text':
                    annotationCtx.fillStyle = obj.colorHex;
                    annotationCtx.font = `${obj.fontSize * currentCanvasScale}px ${obj.fontName === 'Cairo' ? 'Cairo, sans-serif' : obj.fontName}`;
                    annotationCtx.textBaseline = 'top';
                    let textX = x;
                    if (obj.align === 'center') { annotationCtx.textAlign = 'center'; textX = x + w / 2; }
                    else if (obj.align === 'left') { annotationCtx.textAlign = 'left'; textX = x; }
                    else { annotationCtx.textAlign = 'right'; textX = x + w; }
                    annotationCtx.fillText(obj.content, textX, y);
                    break;
                case 'highlight':
                    annotationCtx.fillStyle = obj.colorHex;
                    annotationCtx.fillRect(x, y, w, h);
                    break;
                case 'rect': case 'circle':
                    if (obj.fillColorHex) {
                        annotationCtx.fillStyle = obj.fillColorHex;
                        if (obj.type === 'rect') annotationCtx.fillRect(x, y, w, h);
                        else { annotationCtx.beginPath(); annotationCtx.arc(x + w / 2, y + h / 2, w / 2, 0, 2 * Math.PI); annotationCtx.fill(); }
                    }
                    if (obj.strokeColorHex && obj.strokeWidth > 0) {
                        annotationCtx.strokeStyle = obj.strokeColorHex;
                        annotationCtx.lineWidth = obj.strokeWidth * currentCanvasScale;
                        if (obj.type === 'rect') annotationCtx.strokeRect(x, y, w, h);
                        else { annotationCtx.beginPath(); annotationCtx.arc(x + w / 2, y + h / 2, w / 2, 0, 2 * Math.PI); annotationCtx.stroke(); }
                    }
                    break;
                case 'line': case 'arrow':
                    if (!obj.points || obj.points.length < 2) break;
                    annotationCtx.beginPath();
                    annotationCtx.moveTo(obj.points[0].x * currentCanvasScale, obj.points[0].y * currentCanvasScale);
                    annotationCtx.lineTo(obj.points[1].x * currentCanvasScale, obj.points[1].y * currentCanvasScale);
                    annotationCtx.strokeStyle = obj.strokeColorHex;
                    annotationCtx.lineWidth = obj.strokeWidth * currentCanvasScale;
                    annotationCtx.stroke();
                    if (obj.type === 'arrow') drawCanvasArrowhead(annotationCtx, obj.points[0], obj.points[1], obj.strokeColorHex, obj.strokeWidth);
                    break;
                case 'freehand':
                    if (!obj.points || obj.points.length < 2) break;
                    annotationCtx.beginPath();
                    annotationCtx.moveTo(obj.points[0].x * currentCanvasScale, obj.points[0].y * currentCanvasScale);
                    for (let i = 1; i < obj.points.length; i++) {
                        annotationCtx.lineTo(obj.points[i].x * currentCanvasScale, obj.points[i].y * currentCanvasScale);
                    }
                    annotationCtx.strokeStyle = obj.colorHex;
                    annotationCtx.lineWidth = obj.strokeWidth; // This width is in pixels already
                    annotationCtx.lineCap = "round";
                    annotationCtx.lineJoin = "round";
                    annotationCtx.stroke();
                    break;
                case 'stamp':
                     annotationCtx.fillStyle = obj.colorHex + '4D'; // ~30% opacity
                     annotationCtx.strokeStyle = obj.colorHex;
                     annotationCtx.lineWidth = 2 * currentCanvasScale;
                     if(obj.stampShape === 'circle') {
                        annotationCtx.beginPath();
                        annotationCtx.arc(x + w / 2, y + h / 2, w / 2, 0, 2 * Math.PI);
                        annotationCtx.fill();
                        annotationCtx.stroke();
                     } else {
                        annotationCtx.fillRect(x, y, w, h);
                        annotationCtx.strokeRect(x, y, w, h);
                     }
                     annotationCtx.fillStyle = obj.colorHex;
                     annotationCtx.font = `bold ${w / 4 * currentCanvasScale}px Cairo, sans-serif`;
                     annotationCtx.textAlign = 'center';
                     annotationCtx.textBaseline = 'middle';
                     annotationCtx.fillText(obj.text, x + w / 2, y + h / 2);
                    break;
                case 'image': case 'signature':
                    if (obj.imageElement) annotationCtx.drawImage(obj.imageElement, x, y, w, h);
                    break;
            }
            annotationCtx.restore();
        }

        function drawCanvasArrowhead(ctx, from, to, color, width) {
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const headlen = Math.max(8, width * 2.5) * currentCanvasScale;
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = width * currentCanvasScale;
            ctx.beginPath();
            ctx.moveTo(to.x * currentCanvasScale, to.y * currentCanvasScale);
            ctx.lineTo(to.x * currentCanvasScale - headlen * Math.cos(angle - Math.PI / 6), to.y * currentCanvasScale - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(to.x * currentCanvasScale, to.y * currentCanvasScale);
            ctx.lineTo(to.x * currentCanvasScale - headlen * Math.cos(angle + Math.PI / 6), to.y * currentCanvasScale - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
            ctx.restore();
        }

        function drawSelectionHandles(obj) {
            const x = obj.x * currentCanvasScale;
            const y = obj.y * currentCanvasScale;
            const w = obj.width * currentCanvasScale;
            const h = obj.height * currentCanvasScale;
            annotationCtx.strokeStyle = 'rgba(74, 107, 255, 0.9)';
            annotationCtx.lineWidth = 2;
            annotationCtx.setLineDash([5, 3]);
            annotationCtx.strokeRect(x, y, w, h);
            annotationCtx.setLineDash([]);
        }

        // --- Event Listeners Setup ---
        function setupToolListeners() {
            toolbarButtons.forEach(btn => btn.addEventListener('click', () => setActiveTool(btn.id.replace('Tool', ''))));
            document.getElementById('imageTool').addEventListener('click', () => activeTool === 'image' && imageUploadInput.click());
            document.getElementById('uploadSignatureBtn').addEventListener('click', () => signatureUploadInput.click());
            document.getElementById('drawSignatureBtn').addEventListener('click', () => {
                signaturePadContainer.style.display = 'flex';
                if(!sigPadInstance) {
                    sigPadInstance = new SignaturePad(signaturePadCanvas);
                    const ratio =  Math.max(window.devicePixelRatio || 1, 1);
                    signaturePadCanvas.width = signaturePadCanvas.offsetWidth * ratio;
                    signaturePadCanvas.height = signaturePadCanvas.offsetHeight * ratio;
                    signaturePadCanvas.getContext("2d").scale(ratio, ratio);
                }
                sigPadInstance.clear();
            });
            stampTypeSelect.addEventListener('change', e => {
                const isCustom = e.target.value === 'custom';
                stampTextInput.style.display = isCustom ? 'inline-block' : 'none';
                stampTextInput.previousElementSibling.style.display = isCustom ? 'inline-block' : 'none';
            });
        }

        function setActiveTool(toolId) {
            activeTool = toolId;
            toolbarButtons.forEach(btn => btn.classList.toggle('active', btn.id === `${toolId}Tool`));
            optionsPanels.forEach(p => p.style.display = 'none');
            
            let panelId = null;
            if (toolId === 'text') panelId = 'textOptionsContainer';
            else if (toolId === 'highlight') panelId = 'highlightOptionsContainer';
            else if (['rect', 'circle', 'line', 'arrow'].includes(toolId)) panelId = 'shapeOptionsContainer';
            else if (toolId === 'freehand') panelId = 'freehandOptionsContainer';
            else if (toolId === 'signature') panelId = 'signatureOptionsContainer';
            else if (toolId === 'stamp') panelId = 'stampOptionsContainer';

            toolOptionsContainer.style.display = panelId ? 'flex' : 'none';
            if(panelId) document.getElementById(panelId).style.display = 'flex';
        }

        function setupActionListeners() {
            document.getElementById('saveBtn').addEventListener('click', () => savePdfAnnotations(false));
            document.getElementById('saveCopyBtn').addEventListener('click', () => savePdfAnnotations(true));
            document.getElementById('printBtn').addEventListener('click', printCurrentPdf);
            prevPageBtn.addEventListener('click', () => { if (currentPageNum > 1) { currentPageNum--; renderPdfPage(currentPageNum, false); } });
            nextPageBtn.addEventListener('click', () => { if (currentPageNum < totalPages) { currentPageNum++; renderPdfPage(currentPageNum, false); } });
            addPageBtn.addEventListener('click', addNewPdfPage);
            deletePageBtn.addEventListener('click', deleteCurrentPdfPage);
            deleteBtn.addEventListener('click', deleteSelectedObject);
            document.getElementById('clearPageBtn').addEventListener('click', clearCurrentPageAnnotations);
            imageUploadInput.addEventListener('change', (e) => handleImageUpload(e, 'image'));
            signatureUploadInput.addEventListener('change', (e) => handleImageUpload(e, 'signature'));
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            // Signature Pad actions
            document.getElementById('confirmSignatureBtn').addEventListener('click', confirmSignature);
            document.getElementById('clearSignatureBtn').addEventListener('click', () => sigPadInstance.clear());
            document.getElementById('cancelSignatureBtn').addEventListener('click', () => signaturePadContainer.style.display = 'none');
        }
        
        // --- Canvas Interaction ---
        function setupCanvasListeners() {
            annotationCanvas.addEventListener('mousedown', handleMouseDown);
            annotationCanvas.addEventListener('mousemove', handleMouseMove);
            annotationCanvas.addEventListener('mouseup', handleMouseUp);
            annotationCanvas.addEventListener('mouseleave', () => { if (isDrawing) handleMouseUp(); });
        }

        function handleMouseDown(e) {
            if (isProcessing || e.button !== 0) return;
            
            const coords = getPdfPageCoordinates(e);
            dragStartX = coords.x;
            dragStartY = coords.y;
            currentDrawingPoints = [coords];
            isDrawing = true;

            if (activeTool === 'select') {
                const clickedObject = findObjectAt(coords);
                if (selectedObject !== clickedObject) {
                    selectedObject = clickedObject;
                    renderAnnotations();
                }
            } else if (activeTool === 'eraser') {
                 const clickedObject = findObjectAt(coords);
                 if (clickedObject) {
                    selectedObject = clickedObject;
                    deleteSelectedObject();
                 }
                 isDrawing = false;
            } else {
                selectedObject = null;
                renderAnnotations();
            }
        }
        
        function handleMouseMove(e) {
            if (!isDrawing) return;
            const coords = getPdfPageCoordinates(e);

            if (activeTool === 'select' && selectedObject) {
                const dx = coords.x - dragStartX;
                const dy = coords.y - dragStartY;
                selectedObject.x += dx;
                selectedObject.y += dy;
                if(selectedObject.points) {
                    selectedObject.points.forEach(p => { p.x += dx; p.y += dy; });
                }
                dragStartX = coords.x;
                dragStartY = coords.y;
                renderAnnotations();
            } else if (['rect', 'highlight', 'circle', 'line', 'arrow'].includes(activeTool)) {
                renderAnnotations();
                const tempObj = { type: activeTool, opacity: 1 };
                if (activeTool === 'line' || activeTool === 'arrow') {
                    tempObj.points = [{x: dragStartX, y: dragStartY}, {x: coords.x, y: coords.y}];
                    tempObj.strokeColorHex = strokeColorInput.value;
                    tempObj.strokeWidth = strokeWidthInput.value;
                } else {
                    tempObj.x = Math.min(dragStartX, coords.x);
                    tempObj.y = Math.min(dragStartY, coords.y);
                    tempObj.width = Math.abs(coords.x - dragStartX);
                    tempObj.height = Math.abs(coords.y - dragStartY);
                    tempObj.fillColorHex = activeTool === 'highlight' ? highlightColorInput.value : fillColorInput.value;
                    tempObj.strokeColorHex = strokeColorInput.value;
                    tempObj.strokeWidth = strokeWidthInput.value;
                }
                drawAnnotationObject(tempObj);
            } else if (activeTool === 'freehand') {
                currentDrawingPoints.push(coords);
                renderAnnotations();
                drawAnnotationObject({ type: 'freehand', points: currentDrawingPoints, colorHex: freehandColorInput.value, strokeWidth: freehandWidthInput.value });
            }
        }

        function handleMouseUp(e) {
            if (!isDrawing) return;
            isDrawing = false;
            const coords = getPdfPageCoordinates(e);
            let newObject = null;
            
            if (activeTool === 'select' && selectedObject) {
                 if(coords.x !== dragStartX || coords.y !== dragStartY) saveStateForUndo();
            } else if (activeTool === 'text') {
                 const text = prompt("أدخل النص:");
                 if (text) {
                    const fontSize = parseInt(fontSizeInput.value);
                    const tempCtx = document.createElement('canvas').getContext('2d');
                    tempCtx.font = `${fontSize}px ${fontSelector.value}`;
                    const textWidth = tempCtx.measureText(text).width;
                    let xPos = coords.x;
                    if(textAlignSelect.value === 'center') xPos -= textWidth / 2;
                    else if(textAlignSelect.value === 'right') xPos -= textWidth;

                    newObject = { id: generateId(), type: 'text', content: text, x: xPos, y: coords.y, width: textWidth, height: fontSize * 1.2, colorHex: textColorInput.value, fontSize: fontSize, fontName: fontSelector.value, align: textAlignSelect.value };
                 }
            } else if (['rect', 'highlight', 'circle', 'line', 'arrow'].includes(activeTool)) {
                const width = Math.abs(coords.x - dragStartX);
                const height = Math.abs(coords.y - dragStartY);

                if(activeTool === 'line' || activeTool === 'arrow') {
                    if (width > 2 || height > 2) {
                        newObject = {
                            id: generateId(), type: activeTool,
                            points: [{x: dragStartX, y: dragStartY}, {x: coords.x, y: coords.y}],
                            x: Math.min(dragStartX, coords.x), y: Math.min(dragStartY, coords.y), // Bounding box
                            width, height,
                            strokeColorHex: strokeColorInput.value,
                            strokeWidth: parseInt(strokeWidthInput.value),
                            opacity: parseFloat(shapeOpacityInput.value)
                        };
                    }
                } else { // rect, circle, highlight
                    if (width > MIN_OBJECT_SIZE && height > MIN_OBJECT_SIZE) {
                        newObject = {
                            id: generateId(), type: activeTool,
                            x: Math.min(dragStartX, coords.x), y: Math.min(dragStartY, coords.y),
                            width, height,
                            fillColorHex: activeTool === 'highlight' ? highlightColorInput.value : (activeTool === 'circle' ? strokeColorInput.value : fillColorInput.value),
                            strokeColorHex: strokeColorInput.value,
                            strokeWidth: parseInt(strokeWidthInput.value),
                            opacity: activeTool === 'highlight' ? parseFloat(highlightOpacityInput.value) : parseFloat(shapeOpacityInput.value)
                        };
                    }
                }
            } else if (activeTool === 'freehand') {
                if (currentDrawingPoints.length > 1) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    currentDrawingPoints.forEach(p => {
                        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
                    });
                    newObject = { id: generateId(), type: 'freehand', points: currentDrawingPoints, x: minX, y: minY, width: maxX - minX, height: maxY - minY, colorHex: freehandColorInput.value, strokeWidth: parseInt(freehandWidthInput.value) };
                }
            } else if (activeTool === 'stamp') {
                const stampType = stampTypeSelect.value;
                const text = stampType === 'custom' ? stampTextInput.value : STAMP_TEXTS[stampType];
                if (text) {
                    const size = 80;
                    newObject = { id: generateId(), type: 'stamp', text, x: coords.x - size / 2, y: coords.y - size / 2, width: size, height: size, colorHex: stampColorInput.value, stampShape: ['approved', 'rejected'].includes(stampType) ? 'circle' : 'rect' };
                }
            }

            if(newObject) {
                editsPerPage[currentPageNum - 1].push(newObject);
                saveStateForUndo();
                selectedObject = newObject;
                renderAnnotations();
            }
        }
        
        function findObjectAt(coords) {
            const pageEdits = editsPerPage[currentPageNum - 1] || [];
            for (let i = pageEdits.length - 1; i >= 0; i--) {
                const obj = pageEdits[i];
                if(obj.type === 'line' || obj.type === 'arrow') {
                    if (isPointNearLine(coords, obj.points[0], obj.points[1], obj.strokeWidth)) return obj;
                } else if(obj.type === 'freehand') {
                    for (let j = 0; j < obj.points.length - 1; j++) {
                        if (isPointNearLine(coords, obj.points[j], obj.points[j+1], obj.strokeWidth)) return obj;
                    }
                } else if (coords.x >= obj.x && coords.x <= obj.x + obj.width && coords.y >= obj.y && coords.y <= obj.y + obj.height) {
                    return obj;
                }
            }
            return null;
        }

        function isPointNearLine(p, a, b, width) {
            const tolerance = Math.max(5, width) / currentCanvasScale;
            const L2 = Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2);
            if (L2 === 0) return Math.sqrt(Math.pow(p.x - a.x, 2) + Math.pow(p.y - a.y, 2)) < tolerance;
            const t = Math.max(0, Math.min(1, ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / L2));
            const projX = a.x + t * (b.x - a.x);
            const projY = a.y + t * (b.y - a.y);
            return Math.sqrt(Math.pow(p.x - projX, 2) + Math.pow(p.y - projY, 2)) < tolerance;
        }


        async function handleImageUpload(e, type) {
            const file = e.target.files[0];
            if (!file) return;

            const imageBytes = await file.arrayBuffer();
            const imageElement = new Image();
            const objectURL = URL.createObjectURL(file);
            
            imageElement.onload = () => {
                URL.revokeObjectURL(objectURL);
                const aspectRatio = imageElement.width / imageElement.height;
                const width = type === 'signature' ? 120 : 150;
                const height = width / aspectRatio;
                const { clientWidth, clientHeight } = canvasContainer;
                
                const newImageObject = {
                    id: generateId(), type,
                    x: (clientWidth / 2 / currentCanvasScale) - (width/2),
                    y: (clientHeight / 2 / currentCanvasScale) - (height/2),
                    width, height, imageBytes, imageType: file.type, imageElement
                };
                editsPerPage[currentPageNum - 1].push(newImageObject);
                saveStateForUndo();
                selectedObject = newImageObject;
                renderAnnotations();
            };
            imageElement.src = objectURL;
            e.target.value = null;
        }

        function confirmSignature() {
            if (sigPadInstance.isEmpty()) {
                alert("يرجى الرسم أولاً.");
                return;
            }
            const dataUrl = sigPadInstance.toDataURL('image/png');
            signaturePadContainer.style.display = 'none';

            const imageElement = new Image();
            imageElement.onload = () => {
                const aspectRatio = imageElement.width / imageElement.height;
                const width = 120;
                const height = width / aspectRatio;
                
                const newSigObject = {
                    id: generateId(), type: 'signature',
                    x: (canvasContainer.clientWidth / 2 / currentCanvasScale) - (width / 2),
                    y: (canvasContainer.clientHeight / 2 / currentCanvasScale) - (height / 2),
                    width, height, imageElement,
                    imageBytes: Uint8Array.from(atob(dataUrl.split(',')[1]), c => c.charCodeAt(0)).buffer,
                    imageType: 'image/png'
                };
                editsPerPage[currentPageNum - 1].push(newSigObject);
                saveStateForUndo();
                selectedObject = newSigObject;
                renderAnnotations();
            };
            imageElement.src = dataUrl;
        }

        function deleteSelectedObject() {
            if (!selectedObject) return;
            const pageEdits = editsPerPage[currentPageNum - 1];
            const index = pageEdits.findIndex(obj => obj.id === selectedObject.id);
            if (index > -1) {
                pageEdits.splice(index, 1);
                saveStateForUndo();
                selectedObject = null;
                renderAnnotations();
            }
        }
        function clearCurrentPageAnnotations() {
            if(confirm("هل أنت متأكد من مسح جميع التعديلات في هذه الصفحة؟")) {
                editsPerPage[currentPageNum - 1] = [];
                saveStateForUndo();
                selectedObject = null;
                renderAnnotations();
            }
        }
        
        async function addNewPdfPage() {
            if (!pdfLibDoc) pdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer);
            pdfLibDoc.addPage();
            editsPerPage.splice(currentPageNum, 0, []);
            totalPages = pdfLibDoc.getPageCount();
            statusDiv.textContent = `تمت إضافة صفحة. العدد الإجمالي الآن ${totalPages}. ستظهر بعد الحفظ.`;
        }

        async function deleteCurrentPdfPage() {
            if (!pdfLibDoc) pdfLibDoc = await PDFDocument.load(pdfLibDocArrayBuffer);
            if (pdfLibDoc.getPageCount() <= 1) return alert("لا يمكن حذف الصفحة الوحيدة.");
            if (confirm(`هل تريد بالتأكيد حذف الصفحة ${currentPageNum}؟ سيتم الحذف عند الحفظ.`)) {
                pdfLibDoc.removePage(currentPageNum - 1);
                editsPerPage.splice(currentPageNum - 1, 1);
                totalPages = pdfLibDoc.getPageCount();
                if (currentPageNum > totalPages) currentPageNum = totalPages;
                statusDiv.textContent = `تم حذف الصفحة. العدد المتبقي ${totalPages}. سيُطبق التغيير عند الحفظ.`;
            }
        }

        // --- Saving Logic ---
        async function savePdfAnnotations(asCopy = false) {
            if (!originalPdfFile || isProcessing) return;
            isProcessing = true;
            statusDiv.innerHTML = 'جاري حفظ الملف...';
            updateUIState();

            try {
                let workingPdfDoc = asCopy ? await PDFDocument.load(pdfLibDocArrayBuffer) : (pdfLibDoc || await PDFDocument.load(pdfLibDocArrayBuffer));
                workingPdfDoc.registerFontkit(window.fontkit);
                const embeddedFonts = {};

                for (let i = 0; i < editsPerPage.length; i++) {
                    const pageEdits = editsPerPage[i];
                    if (!pageEdits || pageEdits.length === 0 || i >= workingPdfDoc.getPageCount()) continue;

                    const page = workingPdfDoc.getPage(i);
                    const { height: pageHeight } = page.getSize();
                    
                    for (const obj of pageEdits) {
                        const y = pageHeight - obj.y - obj.height; // Y-coordinate conversion for boxes/images
                        
                        if (obj.type === 'text') {
                            if (!embeddedFonts[obj.fontName]) {
                                if (obj.fontName === 'Cairo') {
                                    const fontBytes = await fetch(DEFAULT_FONT_PATH).then(res => res.arrayBuffer());
                                    embeddedFonts[obj.fontName] = await workingPdfDoc.embedFont(fontBytes);
                                } else {
                                    embeddedFonts[obj.fontName] = await workingPdfDoc.embedFont(StandardFonts[obj.fontName] || StandardFonts.Helvetica);
                                }
                            }
                            let xPos = obj.x;
                            if(obj.align === 'center') xPos += obj.width / 2;
                            else if(obj.align === 'right') xPos += obj.width;
                            
                            page.drawText(obj.content, { x: xPos, y: pageHeight - obj.y - obj.fontSize, size: obj.fontSize, font: embeddedFonts[obj.fontName], color: hexToRgb(obj.colorHex), opacity: obj.opacity, alignment: TextAlignment[obj.align] });
                        } else if (obj.type === 'image' || obj.type === 'signature') {
                            if (!obj.imageBytes) continue;
                            const image = await (obj.imageType === 'image/png' ? workingPdfDoc.embedPng(obj.imageBytes) : workingPdfDoc.embedJpg(obj.imageBytes));
                            page.drawImage(image, { x: obj.x, y, width: obj.width, height: obj.height, opacity: obj.opacity });
                        } else if (['rect', 'highlight', 'circle'].includes(obj.type)) {
                            const options = { x: obj.x, y, width: obj.width, height: obj.height, color: hexToRgb(obj.fillColorHex), borderColor: hexToRgb(obj.strokeColorHex), borderWidth: obj.strokeWidth, opacity: obj.opacity };
                            if (obj.type === 'circle') {
                                options.x += obj.width / 2; options.y += obj.height / 2;
                                page.drawCircle(options);
                            } else page.drawRectangle(options);
                        } else if(obj.type === 'line' || obj.type === 'arrow'){
                            page.drawLine({
                                start: { x: obj.points[0].x, y: pageHeight - obj.points[0].y },
                                end:   { x: obj.points[1].x, y: pageHeight - obj.points[1].y },
                                thickness: obj.strokeWidth, color: hexToRgb(obj.strokeColorHex), opacity: obj.opacity
                            });
                            if (obj.type === 'arrow') {
                                const angle = Math.atan2(obj.points[1].y - obj.points[0].y, obj.points[1].x - obj.points[0].x);
                                const headlen = Math.max(8, obj.strokeWidth * 2.5);
                                const x1 = obj.points[1].x, y1_pdf = pageHeight - obj.points[1].y;
                                const p2x = x1 - headlen * Math.cos(angle - Math.PI / 6);
                                const p2y = y1_pdf - headlen * Math.sin(angle - Math.PI / 6);
                                const p3x = x1 - headlen * Math.cos(angle + Math.PI / 6);
                                const p3y = y1_pdf - headlen * Math.sin(angle + Math.PI / 6);
                                page.drawSvgPath(`M ${x1} ${y1_pdf} L ${p2x} ${p2y} M ${x1} ${y1_pdf} L ${p3x} ${p3y}`, { borderColor: hexToRgb(obj.strokeColorHex), borderWidth: obj.strokeWidth });
                            }
                        } else if(obj.type === 'freehand'){
                            const path = obj.points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${pageHeight - p.y}`).join(' ');
                            page.drawSvgPath(path, { borderColor: hexToRgb(obj.colorHex), borderWidth: obj.strokeWidth });
                        } else if (obj.type === 'stamp') {
                            const color = hexToRgb(obj.colorHex);
                            const fillColor = { ...color, a: 0.3 };
                            if(obj.stampShape === 'circle') {
                                page.drawCircle({ x: obj.x + obj.width / 2, y: y + obj.height / 2, size: obj.width / 2, color: fillColor, borderColor: color, borderWidth: 2 });
                            } else {
                                page.drawRectangle({ x: obj.x, y, width: obj.width, height: obj.height, color: fillColor, borderColor: color, borderWidth: 2 });
                            }
                            page.drawText(obj.text, { x: obj.x + obj.width / 2, y: y + obj.height / 2 - (obj.width / 8), font: await workingPdfDoc.embedFont(StandardFonts.HelveticaBold), size: obj.width / 4, color, alignment: TextAlignment.Center });
                        }
                    }
                }
                
                const pdfBytes = await workingPdfDoc.save();
                if (!asCopy) { pdfLibDocArrayBuffer = pdfBytes.slice(0); pdfLibDoc = workingPdfDoc; }

                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                let filename = document.getElementById('outputBaseFilename').value.trim() || originalPdfFile.name.replace(/\.pdf$/i, '_مُعدل.pdf');
                if (!filename.toLowerCase().endsWith('.pdf')) filename += '.pdf';
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

                statusDiv.textContent = 'تم حفظ الملف بنجاح!';

            } catch (err) {
                console.error("Error saving PDF:", err);
                statusDiv.textContent = `خطأ أثناء الحفظ: ${err.message}`;
            } finally {
                isProcessing = false;
                updateUIState();
            }
        }
        
        async function printCurrentPdf() { /* ... similar to save logic but opens print dialog ... */ }
        function setupContextMenu() { /* ... unchanged ... */ }
        
        function setupZoomControls() {
             zoomInBtn.addEventListener('click', () => { currentCanvasScale *= 1.2; renderPdfPage(currentPageNum, false); });
             zoomOutBtn.addEventListener('click', () => { currentCanvasScale /= 1.2; renderPdfPage(currentPageNum, false); });
             zoomFitBtn.addEventListener('click', () => renderPdfPage(currentPageNum, true));
        }

        function updateHistoryButtons() {
            undoBtn.disabled = undoStack.length === 0 || isProcessing;
            redoBtn.disabled = redoStack.length === 0 || isProcessing;
        }

        function updateUIState() {
            const fileLoaded = !!pdfJsDoc;
            document.querySelectorAll('#editorArea button, #editorArea input, #editorArea select, #saveBtn, #saveCopyBtn, #printBtn').forEach(el => {
                el.disabled = !fileLoaded || isProcessing;
            });

            if (fileLoaded) {
                pageIndicator.textContent = `صفحة ${currentPageNum} / ${totalPages}`;
                prevPageBtn.disabled = currentPageNum <= 1 || isProcessing;
                nextPageBtn.disabled = currentPageNum >= totalPages || isProcessing;
                deleteBtn.disabled = !selectedObject || isProcessing;
                zoomLevelDisplay.textContent = `${Math.round(currentCanvasScale * 100)}%`;
            } else {
                editorArea.style.display = 'none';
            }
            if(isProcessing) statusDiv.innerHTML += ' <div class="spinner"></div>';
            updateHistoryButtons();
        }

        initializeEditor();
    </script>
</body>
</html>